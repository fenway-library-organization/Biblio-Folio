#!/usr/bin/perl

$| = 1;

use strict;
use warnings;

sub dd;
sub usage;
sub fatal;

use FindBin qw($Bin);
use lib "$Bin/../lib";

use Biblio::Folio;

use LWP::UserAgent;
use HTTP::Headers;
use JSON;
use YAML::XS;
use File::Spec;
use Time::HiRes qw(time);
use MARC::Loop qw(marcparse marcfield marcbuild TAG VALREF DELETE IND1 IND2 SUBS);
use Getopt::Long
    qw(:config posix_default gnu_compat require_order bundling no_ignore_case);

(my $prog = $0) =~ s{.*/}{};
my $progfile = File::Spec->rel2abs($0);

my ($root, $folio, $site_name, $site, $json);
# Common options
my ($dryrun, $verbose, %tracing);

GetOptions(
    's|site=s' => \$site_name,
    'T|tracing:s' => sub {_parse_tracing($_[1]) },
);
usage if !@ARGV;
if ($ARGV[0] =~ s/^\@(.+)//) {
    fatal "ambiguous site name: -s $site_name or \@$1?"
        if defined($site_name) && $site_name ne $1;
    $site_name = $1;
    shift @ARGV;
    usage if !@ARGV;
}
my $cmd = shift @ARGV;
$cmd =~ tr/-/_/;

&{ __PACKAGE__->can('cmd_'.$cmd) or usage };

# --- Command handlers

sub cmd_status {
    orient();
    my $state = $site->state;
	print $json->encode($state);
}

sub cmd_login {
    my ($check);
    orient(
        'k|check' => \$check,
    );
    if ($check) {
        usage "login [-k USER PASSWORD]"
            if @ARGV != 2;
        login_if_necessary();
        my $result = $site->authenticate(
            'username' => $ARGV[0],
            'password' => $ARGV[1],
        );
        if ($result) {
            print STDERR "authentication succeeded\n";
            print STDERR "  token:  $result->{'token'}\n";
            print STDERR "  userId: $result->{'userId'}\n"
                if defined $result->{'userId'};
        }
        else {
            print STDERR "authentication failed\n";
            exit 2;
        }
    }
    else {
        $site->login('force' => 1);
        my $state = $site->state;
        printf STDERR <<'EOS', $state->{'user_id'} // '<null>', $state->{'token'};
Logged in:
  userId = %s
  token  = %s
EOS
    }
}

sub cmd_get {
    orient();
    usage "get URI [KEY=VAL]..." if !@ARGV;
    my @args = (shift @ARGV);
    if (@ARGV) {
        my %arg;
        foreach (@ARGV) {
            usage if !/^([^=]+)=(.*)/;
            $arg{$1} = $2;
        }
        push @args, \%arg;
    }
    my $res = $site->GET(@args);
    if (!$res->is_success) {
        print STDERR $res->status_line, "\n";
        exit 2;
    }
    print $json->encode($json->decode($res->content));
}

sub cmd_post {
    orient();
    usage "post URI JSONFILE|[KEY=VAL]..." if !@ARGV;
    my $uri = shift @ARGV;
    my @args;
    if (@ARGV == 1 && $ARGV[0] !~ /^([^=]+)=(.*)$/) {
        push @args, read_json(oread(shift @ARGV));
    }
    elsif (@ARGV) {
        my %arg;
        foreach (@ARGV) {
            usage if !/^([^=]+)=(.*)$/;
            $arg{$1} = $2;
        }
        push @args, \%arg;
    }
    my $res = $site->POST($uri, @args);
    print $json->encode($json->decode($res->content));
}

sub cmd_put {
    orient();
    usage "put URI JSONFILE|[KEY=VAL]..." if !@ARGV;
    my $uri = shift @ARGV;
    my @args;
    if (@ARGV == 1 && $ARGV[0] !~ /^([^=]+)=(.*)$/) {
        push @args, read_json(oread(shift @ARGV));
    }
    elsif (@ARGV) {
        my %arg;
        foreach (@ARGV) {
            usage if !/^([^=]+)=(.*)$/;
            $arg{$1} = $2;
        }
        push @args, \%arg;
    }
    my $res = $site->PUT($uri, @args);
    print $json->encode($json->decode($res->content));
}

sub cmd_instance {
    subcmd();
}

sub cmd_instance_get {
    my ($with_holdings, $with_items, @properties);
    orient(
        'h|with-holdings' => \$with_holdings,
        'i|with-items' => \$with_items,
        'p|properties=s' => sub { push @properties, split /\,/, $_[1] },
    );
    usage "instance get INSTANCE_ID..." if !@ARGV;
    foreach my $id (@ARGV) {
        my $instance = $site->instance($id);
        my ($err) = split /\n/, $@;
        if (!$instance) {
            $err = ': ' if $err =~ /\S/;
            print STDERR "instance $id not found$err\n";
        }
        elsif (@properties) {
            my $propvals = $instance->properties(@properties);
            print $json->encode($propvals);
        }
        else {
            print $json->encode($instance);
        }
    }
}

sub cmd_instance_search {
    orient();
    usage "instance search CQL" if @ARGV != 1;
    my ($cql) = @ARGV;
    my $srec = $site->GET("/inventory/instances", {
        'query' => $cql,
    });
    print $srec->content;
}

sub cmd_instance_source {
    subcmd();
}

sub cmd_instance_source_get {
    my %format;
    orient(
        'J|as-json' => sub { $format{'JSON'} = 1 },
        'M|as-marc' => sub { $format{'MARC'} = 1 },
        'T|as-text' => sub { $format{'TEXT'} = 1 },
    );
    usage "instance source get [-jmt] INSTANCE_ID..." if !@ARGV;
    usage if keys(%format) > 1;
    $format{'JSON'} = 1 if keys(%format) == 0;
    foreach my $id (@ARGV) {
        my $source = $site->instance_source($id);
        1;
        my $res = $site->GET("/source-storage/formattedRecords/$id", {
            identifier => 'INSTANCE',
        });
        my $content = $json->decode($res->content);
        my $rectype = $content->{'recordType'};
        if ($format{'MARC'}) {
            if ($rectype ne 'MARC') {
                print STDERR "record not in MARC format; $id\n";
                next;
            }
            my $marc = $content->{'rawRecord'}{'content'};
            my $sid = $content->{'id'};
            print_cooked_marc(
                'marcref' => \$marc,
                'instance_id' => $id,
                'source_id' => $sid,
                'strict' => 1,
            );
            #my %opt = (
            #    'error' => sub { die @_ },
            #);
            #my ($leader, $fields, $marcref) = marcparse(\$marc, \%opt);
            #1;
            #print $marc;
        }
        elsif ($format{'TEXT'}) {
            if ($rectype ne 'MARC') {
                print STDERR "record not in MARC format; $id\n";
                next;
            }
            print $content->{'parsedRecord'}{'formattedContent'};
        }
        else {
            print $json->encode($content->{'parsedRecord'}{'content'});
        }
    }
}

sub cmd_instance_source_replace {
}

sub cmd_instance_harvest {
    my (%with, %as, $mod, $id_file);
    my ($query, $max_count, $batch_size, $max_err);
    orient(
        'j|as-json' => \$as{'json'},
        'm|as-marc' => \$as{'marc'},
        'h|with-holdings' => \$with{'holdings'},
        'i|with-items'    => \$with{'items'},
        'n|limit=i' => \$max_count,
        'k|batch-size=i' => \$batch_size,
        'e|max-errors=i' => \$max_err,
        'p|progress=i' => \$mod,
        'f|id-file=s' => \$id_file,
        'q|query=s' => \$query,
    );
    usage "instance harvest [-jmhi] [-n MAXNUM] [-k BATCHSIZE] [-e MAXERRS] [-f FILE|-q CQL|ID...]"
        if ($id_file && $query)
        || ($id_file && @ARGV)
        || ($query   && @ARGV)
        ;
    $with{'holdings'} = 1 if $with{'items'};
    my $t0 = time;
    my $err = 0;
    my $remaining = $max_count || (1<<31);
    my $fetch;
    my @prefix = qq{\{"instances":[\n};
    if (defined $query) {
        my $offset = 0;
        if (!defined $batch_size) {
            $batch_size = (!defined $max_count || $max_count > 100) ? 100 : $max_count;
        }
        $fetch = sub {
            my $limit = $batch_size > $remaining ? $remaining : $batch_size;
            my @instances = $site->instance(
                'query' => $query,
                'offset' => $offset,
                'limit' => $limit,
            );
            my $n = scalar @instances;
            $remaining = 0, return if !$n;
            $remaining -= $n;
            $offset += $n;
            return @instances;
        };
    }
    else {
        my $next;
        if (@ARGV) {
            $next = sub {
                return if !@ARGV;
                return shift @ARGV;
            };
        }
        else {
            my $fh = @ARGV ? oread(@ARGV) : \*STDIN;
            $next = sub {
                my $id = <$fh>;
                return if !defined $id;
                $id =~ s/\s+.*//;
                return $id;
            };
        }
        $fetch = sub {
            while (1) {
                my $id = $next->();
                $remaining = 0, return if !defined $id;
                my (@instance, $ok);
                eval { @instance = $site->instance($id); $ok = 1 };
                if (!$ok) {
                    my ($msg) = split /\n/, $@;
                    $msg = 'unknown error' if $msg !~ /\S/;
                    print STDERR "can't fetch instance $id: $msg\n";
                    $err++;
                }
                elsif (@instance) {
                    $remaining -= @instance;
                    return @instance;
                }
            }
        };
    }
    my %num = qw(instances 0 holdings 0 items 0);
    my $n = 0;
    while (1) {
        my @instances = $fetch->();
        last if !@instances;
        foreach my $instance (@instances) {
            $num{'instances'}++;
            $n++;
            my $id = $instance->id;
            if ($as{'marc'}) {
                my $marc;
                eval {
                    $marc = $instance->marc_record;
                    my ($leader, $fields) = eval { marcparse(\$marc) };
                    @$fields = (
                        marcfield('001', $id),
                        grep { $_->[TAG] !~ /^(001|003|852|859|9)/ } @$fields
                    );
                    my $classifier;
                    my $f33x = _33x_field_subfields($fields);
                    $classifier = 'audiobook' if $f33x->{'336'}{'spw'};
                    $classifier = 'ebook' if $f33x->{'336'}{'txt'} && $f33x->{'338'}{'cr'};
                    if ($with{'holdings'}) {
                        my @holdings = $instance->holdings;
                        my $num_holdings = @holdings;
                        if ($num_holdings) {
                            my $num_items = add_holdings_to_marc_fields(
                                'fields' => $fields,
                                'holdings' => \@holdings,
                                'add_items' => $with{'items'},
                                'classifier' => $classifier,
                            );
                            $num{'holdings'} += $num_holdings;
                            $num{'items'} += $num_items;
                            $n += $num_holdings + $num_items;
                        }
                    }
                    $marc = marcbuild($leader, $fields);
                };
                if (!defined $marc) {
                    $marc = _marc_delete_stub($id);
                    print STDERR "not found: $id\n"
                        if $verbose;
                }
                print $marc;
            }
            elsif ($as{'json'}) {
                if ($with{'holdings'}) {
                    my @holdings = $instance->holdings;
                    $instance->{'holdings'} = \@holdings;
                    my $num_holdings = @holdings;
                    if ($with{'items'}) {
                        foreach my $holding (@holdings) {
                            my @items = $holding->items;
                            $holding->{'items'} = \@items;
                            $num{'items'} += @items;
                            $n += @items;
                        }
                    }
                    $num{'holdings'} += @holdings;
                    $n += @holdings;
                }
                my $out = $json->encode($instance);
                $out =~ s/\n+\z//;
                print @prefix, $out;
                @prefix = ',';
            }
        }
        if ($verbose && defined $query || $mod && ($n % $mod) == 0) {
            printf STDERR "\r%8d instances : %8d holdings : %8d items",
                @num{qw(instances holdings items)};
        }
    }
    print "\n]\n}\n" if $as{'json'};
    if ($verbose && defined $query || $mod) {
        printf STDERR "\r%8d instances : %8d holdings : %8d items => %.1f seconds\n",
            @num{qw(instances holdings items)},
            time - $t0;
    }
}

sub cmd_holding {
    subcmd();
}

sub cmd_holding_get {
    orient();
    usage "holding get HOLDING_ID..." if !@ARGV;
    foreach my $id (@ARGV) {
        my $irec = eval { get_holding($id) };
        my ($err) = split /\n/, $@;
        if ($irec) {
            my $holding = $json->decode($irec->content);
            print $json->encode($holding);
        }
        else {
            $err = ': ' if $err =~ /\S/;
            print STDERR "holding $id not found$err\n";
        }
    }
}

sub cmd_holding_search {
    orient();
    usage "holding search CQL" if @ARGV != 1;
    my ($cql) = @ARGV;
    my $srec = $site->GET("/holdings-storage/holdings", {
        'query' => $cql,
    });
    print $srec->content;
}

sub cmd_item {
    subcmd();
}

sub cmd_item_get {
    orient();
    usage "item get ITEM_ID..." if !@ARGV;
    foreach my $id (@ARGV) {
        my $irec = eval { get_item($id) };
        my ($err) = split /\n/, $@;
        if ($irec) {
            my $item = $json->decode($irec->content);
            print $json->encode($item);
        }
        else {
            $err = ': ' if $err =~ /\S/;
            print STDERR "item $id not found$err\n";
        }
    }
}

sub cmd_item_search {
    orient();
    usage "item search CQL" if @ARGV != 1;
    my ($cql) = @ARGV;
    my $srec = $site->GET("/item-storage/items", {
        'query' => $cql,
    });
    print $srec->content;
}

sub cmd_source {
    subcmd();
}

sub cmd_source_get {
    orient();
    usage "source get SOURCE_RECORD_ID..." if !@ARGV;
    foreach my $id (@ARGV) {
        my $srec = eval { $json->decode($site->GET("/source-storage/records/$id")->content) };
        my ($err) = split /\n/, $@;
        if (defined $srec) {
            my $instance_id = $srec->{'externalIdsHolder'}{'instanceId'} || $srec->{'instanceId'};
            print_cooked_marc(
                'marcref' => \$srec->{'rawRecord'}{'content'}, 
                'instance_id' => $instance_id,
                'source_id' => $id,
                'strict' => 1,
            );
        }
        else {
            $err = ': ' if $err =~ /\S/;
            print STDERR "record $id not found$err\n";
        }
    }
}

sub cmd_source_search {
    my %arg;
    my %format = ('JSON' => 1);
    orient(
        'm|offset=i' => \$arg{'offset'},
        'n|limit=i' => \$arg{'limit'},
        'o|order-by=s' => \$arg{'order_by'},
        'd|deleted' => sub { $arg{'deleted'} = JSON::true },
        'J|as-json' => sub { %format = ('JSON' => 1) },
        'M|as-json' => sub { %format = ('MARC' => 1) },
    );
    usage "source search [-m POS] [-n LIMIT] [-o KEY] [-dJM] CQL" if @ARGV != 1;
    my ($cql) = @ARGV;
    my $content = cql_search_results('/source-storage/records', $cql, %arg);
    my ($total, $sources) = @$content{qw(totalRecords records)};
    my $n = 0;
    foreach my $srec (@$sources) {
        $n++;
        my $rectype = $srec->{'recordType'};
        if ($format{'MARC'}) {
            if ($rectype ne 'MARC') {
                print STDERR "record not in MARC format: $cql [$n]\n";
                next;
            }
            my $marc = $srec->{'rawRecord'}{'content'};
            print $marc;
        }
        else {
            print $json->encode($srec->{'parsedRecord'}{'content'});
        }
    }
}

sub cmd_source_replace {
    orient();
    usage "source replace [MARCFILE]" if @ARGV != 1;
    my $fh = oread(@ARGV == 0 ? \*STDIN : shift @ARGV);
    while (my ($marcref) = read_marc_records($fh, 1)) {
        my $id = marc_source_record_id($marcref);
        my $res = $site->PUT("/source-storage/records/$id", 
            'recordType' => 'MARC',
            'rawRecord' => {
                'id' => $folio->uuid,
                'content' => $$marcref,
            },
            'snapshotId' => '',
            'matchedId' => $id,
        );
        1;
    }
}

sub cmd_job {
    subcmd();
}

sub cmd_job_begin {
    orient();
    usage "job begin" if @ARGV;
    my $user_id = $site->state->{'user_id'};
    my %job = (
        'files' => [],
        'sourceType' => 'ONLINE',
        'jobProfileInfo' => {
            'id' => $folio->uuid,
            'name' => 'Random job profile',
            'dataType' => 'MARC'
        },
        'userId' => $user_id || $folio->uuid,
    );
    my $jobexecs = content($site->POST('/change-manager/jobExecutions', \%job));
    if ($jobexecs) {
        my @jobexecs = @{ $jobexecs->{'jobExecutions'} };
        foreach my $jobexec (@jobexecs) {
            my $j = $jobexec->{'id'};
            print "OK $j\n";
        }
        if (@jobexecs > 1) {
            fatal "multiple jobs";
        }
    }
    else {
        fatal "no jobexecs returned";
    }
    # my $snapshot = content($site->POST('/source-storage/snapshots', {
    #     'jobExecutionId' => $j,
    #     'status' => 'NEW',
    # }));
    #     print <<"EOS";
    # OK
    #     job: $j
    #     snapshot: $snapshot->{'id'}
    # 
    # EOS
}

sub cmd_job_add {
    # Add a batch of records to a job
    my ($skip, $batch_size) = (0, 1000);
    orient(
        'p|skip=i' => \$skip,
        'n|batch-size=i' => \$batch_size,
    );
    usage "job add JOB [FILE]" if @ARGV > 2 || @ARGV < 1;
    my $j = shift @ARGV;
    my $uri = "/change-manager/jobExecutions/$j/records";
    my $fh = oread(@ARGV == 0 ? \*STDIN : shift @ARGV);
    my $n = 0;
    my $num_skipped;
    if ($skip) {
        $num_skipped = skip_marc_records($fh, $skip);
    }
    my %metadata = (
        'contentType' => 'MARC_RAW',
        'counter' => $skip,
    );
    my @records;
    # Read the desired number of records (or until EOF)
    if ($skip == 0 || $num_skipped == $skip) {
        my $marcrefs = read_marc_records($fh, $batch_size);
        foreach (@$marcrefs) {
            push @records, { 'record' => $$_ };
        }
        $n += @$marcrefs;
    }
    my %dto = (
        'recordsMetadata' => \%metadata,
        'initialRecords' => \@records,
    );
    if ($n) {
        $metadata{'last'} = JSON::false;
        $metadata{'counter'} += $n;
    }
    elsif ($skip) {
        $metadata{'last'} = JSON::true;
    }
    else {
        fatal "no records to add to the job\n";
    }
    my $res = $site->POST($uri, \%dto);
    if ($res->code eq '204') {
        # Success
        print "OK $j : $n records posted\n";
    }
    elsif ($res->code eq '404') {
        fatal "no such job: $j";
    }
    elsif ($res->code eq '422') {
        # Validation records
        die;
    }
}

sub cmd_source_batch {
    subcmd();
}

sub cmd_source_batch_create {
    my $batch_size = 500;
    orient(
        'n|batch-size=i' => \$batch_size,
    );
    usage "source batch create [FILE]" if @ARGV > 1;
    my $fh = oread(@ARGV == 0 ? \*STDIN : shift @ARGV);
    if (my $marcrefs = read_marc_records($fh, $batch_size)) {
        my $batch = content($site->POST('/source-storage/batch/records', {
            'records' => map { $$_ } $marcrefs,
            'totalRecords' => scalar(@$marcrefs),
        }));
    }
}

sub cmd_user {
    subcmd();
}

sub cmd_group {
    subcmd();
}

sub cmd_group_search {
    my ($map);
    orient(
        'm' => \$map,
    );
    usage "group search CQL" if @ARGV != 1;
    my ($query) = @ARGV;
    my $groups = eval {
        my $res = $site->GET("/groups", {
            query => $query,
        });
        $json->decode($res->content)->{'usergroups'};
    };
    if (!defined $groups) {
        fatal "group find: undefined output";
    }
    elsif ($map) {
        foreach (sort { $a->{'group'} cmp $b->{'group'} } @$groups) {
            print $_->{'id'}, ' ', $_->{'group'}, "\n";
        }
    }
    else {
        print $json->encode($groups);
    }
}

sub cmd_group_get {
    orient();
    usage "group get ID..." if !@ARGV;
    my @groups;
    foreach my $id (@ARGV) {
        my $group = eval { content($site->GET("/groups/$id")) };
        if (defined $group) {
            push @groups, $group;
        }
        else {
            print STDERR "no such group: $id\n";
        }
    }
    print $json->encode(\@groups) if @groups;
}

sub cmd_user_search {
    my ($offset, $limit, $order_by);
    orient(
        'm|offset=i' => \$offset,
        'n|limit=i' => \$limit,
        'o|order-by=s' => \$order_by,
    );
    usage "user search CQL" if @ARGV != 1;
    my ($query) = @ARGV;
    my $users = content($site->GET("/users", {
        'query' => $query,
        _optional('offset' => $offset),
        _optional('limit' => $limit),
        _optional('order_by' => $order_by),
        # 'orderBy' => 'username'
    }));
    print $json->encode($users);
}

sub cmd_user_get {
    orient();
    usage "user get ID..." if !@ARGV;
    my @users;
    foreach my $id (@ARGV) {
        my $user = eval { content($site->GET("/users/$id")) };
        if (defined $user) {
            push @users, $user;
        }
        else {
            print STDERR "no such user: $id\n";
        }
    }
    print $json->encode(\@users) if @users;
}

sub cmd_user_match {
    my %arg;
    orient(
        's|batch-size=i' => \$arg{'batch_size'},
        'p|parser=s' => \$arg{'parser_cls'},
        'j|as_json' => \$arg{'as_json'},
    );
    usage "user match [-j] [-s NUM] [-p CLASS] FILE" if @ARGV != 1;
    match_or_load_users('match', %arg);
}

sub cmd_user_load {
    my %arg;
    orient(
        'n|dry-run' => \$dryrun,
        's|batch-size=i' => \$arg{'batch_size'},
        'p|parser=s' => \$arg{'parser_cls'},
    );
    usage "user load [-n] [-s NUM] [-p CLASS] FILE" if @ARGV != 1;
    match_or_load_users('load', %arg);
}

sub cmd_address {
    subcmd();
}

sub cmd_address_types {
    orient();
    usage "address types" if @ARGV;
    my $res = content($site->GET('/addresstypes'));
    print $json->encode($res);
}

# --- Supporting functions

sub marc_source_record_id {
    my ($marcref) = @_;
    my ($leader, $fields) = marcparse($marcref, 'only' => ['999']);
    return map { $$_ =~ /\x1fs([^\s\x1d-\x1f]+)/ ? ($1) : () } @$fields;
}

sub cql_search_results {
    my ($uri, $cql, %arg) = @_;
    my $srec = eval {
        $site->GET($uri, {
            'query' => $cql,
            _optional('offset' => $arg{'offset'}),
            _optional('limit' => $arg{'limit'}),
            _optional('order_by' => $arg{'order_by'}),
        })
    } or fatal "search failed: $cql";
    return $json->decode($srec->content);
}

sub match_or_load_users {
    my ($verb, %arg) = @_;
    my ($batch_size, $parser_cls) = @arg{qw(batch_size parser_cls)};
    my $config = $site->config;
# $batch_size ||= 5;
    $parser_cls ||= $config->{'users'}{'import'}{'parserClass'} || 'Biblio::FolioX::Util::JSONParser';
    $parser_cls = 'Biblio::FolioX' . $parser_cls if $parser_cls =~ /^[+]/;
    my ($file) = @ARGV;
    use_class($parser_cls);
    my $parser = $parser_cls->new('site' => $site, 'file' => $file);
    my $sub = $verb eq 'match' ? \&show_matching_users : \&update_or_create_user;
    my %count;
    my $n = 0;
    $parser->iterate(
        'batch_size' => $batch_size,
        'each' => sub {
            foreach my $result ($site->match_users(@_)) {
                my ($user, $matches) = @$result{qw(user matches)};
                my $res = $sub->($file, ++$n, \%arg, $user, @$matches);
                $count{$res}++;
            }
        },
    );
    print "result counts {\n";
    foreach my $k (sort keys %count) {
        printf "  %6d %s\n", $count{$k}, $k;
    }
    print "}\n";
}

sub show_matching_users {
    my ($file, $n, $arg, $user, @matches) = @_;
    my $m = @matches;
    my $res = $m == 1 ? 'one' : $m > 1 ? 'multiple' : 'none';
    if ($arg->{'as_json'}) {
        print "# ------------------------------------------------------------------------------\n"
            if $n > 1;
        print $json->encode({
            'index' => $n,
            'input' => $user,
            'matches' => \@matches,
            'result' => $res,
        });
    }
    else {
        printf "user %d \{\n", $n;
        # printf "  id:           %s\n", $user->{'id'};
        printf "  patronGroup:      %s\n", $site->expand_uuid('patronGroup' => $user->{'patronGroup'});
        printf "  hrid:             %s\n", $user->{'hrid'}             if defined $user->{'hrid'};
        printf "  username:         %s\n", $user->{'username'}         if defined $user->{'username'};
        printf "  externalSystemId: %s\n", $user->{'externalSystemId'} if defined $user->{'externalSystemId'};
        printf "  lastName:         %s\n", $user->{'personal'}{'lastName'};
        printf "  firstName:        %s\n", $user->{'personal'}{'firstName'};
        printf "  file:             %s\n", $file;
        printf "  row number:       %s\n", $n;
        printf "  raw data:         %s\n", $user->{'_raw'};
        printf "  matches:          %d\n", $m;
        my $i = 0;
        foreach my $match (@matches) {
            $i++;
            my ($matched_user, $matched_by) = @$match{qw(user by)};
            my $bystr = join(', ', @$matched_by);
            printf "  match %d on %s \{\n", $i, $bystr;
            printf "    id:           %s\n", $matched_user->{'id'};
            printf "    patron group: %s\n", $site->expand_uuid('patronGroup' => $user->{'patronGroup'});
            printf "    hrid:         %s\n", $matched_user->{'hrid'}             if defined $matched_user->{'hrid'};
            printf "    username:     %s\n", $matched_user->{'username'}         if defined $matched_user->{'username'};
            printf "    external id:  %s\n", $matched_user->{'externalSystemId'} if defined $matched_user->{'externalSystemId'};
            printf "    last name:    %s\n", $matched_user->{'personal'}{'lastName'};
            printf "    first name:   %s\n", $matched_user->{'personal'}{'firstName'};
            print  "  \}\n";
        }
        print "\}\n";
    }
    return $res;
}

sub update_or_create_user {
    my ($file, $n, $arg, $user, @matches) = @_;
    my $res;
    if (@matches == 0) {
        $res = $site->POST('/users', $user);
        if ($res->is_success) {
            $user = content($res);
            my $id = $user->{'id'};
            print STDERR "ADD user $id created: record $n in $file\n";
        }
        else {
            print STDERR "ERR user not created: record $n in $file: ", $res->status_line, "\n";
        }
    }
    elsif (@matches == 1) {
        my $match = $matches[0];
        my $id = $match->{'id'};
        my @changes = $site->_apply_update_to_user($match, $user);
        if (!@changes) {
            print STDERR "IGN user $id unchanged: record $n in $file\n";
        }
        else {
            my $res = $site->PUT("/users/$id", $match);
            if ($res->is_success) {
                print STDERR "UPD user $id updated: record $n in $file\n";
            }
            else {
                print STDERR "ERR user $id not updated: record $n in $file: ", $res->status_line, "\n";
            }
        }
    }
    else {
        print STDERR "UNR user unresolved: record $n in $file\n";
    }
}

sub skip_marc_records {
    my ($fh, $n) = @_;
    my $n0 = $n;
    while ($n--) {
        local $/ = "\x1d";
        my $marc = <$fh>;
        last if !defined $marc;
    }
    return $n - $n0;
}

sub read_marc_records {
    my ($fh, $n) = @_;
    my @records;
    $n ||= 1000;
    while ($n--) {
        local $/ = "\x1d";
        my $marc = <$fh>;
        last if !defined $marc;
        push @records, \$marc;
    }
    return \@records;
}

sub read_json {
    my ($fh) = @_;
    local $/;
    my $str = <$fh>;
    return if !defined $str;
    return $json->decode($str);
}

sub oread {
    my ($f) = @_;
    my $fh;
    if ($f eq '-' || $f eq '/dev/stdin') {
        return \*STDIN;
    }
    elsif ($f =~ /\.gz/) {
        open $fh, '-|', 'gunzip', '--stdout', $f
            or fatal "exec gunzip $f: $!";
    }
    else {
        open $fh, '<', $f
            or fatal "open $f: $!";
    }
    return $fh;
}

sub content {
    my ($res) = @_;
    die "no response" if !defined $res;
    my $str = $res->content;
    die "no content" if !defined $str;
    my $content = eval { $json->decode($str) }
        or die "unparseable content";
    return $content;
}

sub subcmd {
    usage if !@ARGV;
    my $subcmd = shift @ARGV;
    my @caller = caller 1;
    $caller[3] =~ /(cmd_\w+)$/ or die;
    goto &{ __PACKAGE__->can($1.'_'.$subcmd) || usage };
}

sub get_instance {
    my ($id) = @_;
    return $site->GET("/inventory/instances/$id");
}

sub get_source_record {
    my ($id) = @_;
}

sub get_holding {
    my ($id) = @_;
    return $site->GET("/holdings-storage/holdings/$id");
}

sub get_item {
    my ($id) = @_;
    return $site->GET("/item-storage/items/$id");
}

sub login_if_necessary {
    my $token = $site->token;
    $site->login('reuse_token' => 1);
    return 0 if defined $token && $token eq $site->token;
    hook('login');
    return 1;
}

sub add_holdings_to_marc_fields {
    my %arg = @_;
    my ($fields, $holdings, $add_items, $classifier) = @arg{qw(fields holdings add_items classifier)};
    my $num_items = 0;
    foreach my $holding (@$holdings) {
        my $loc = $holding->location->code;
        my $call_number = $holding->call_number;
        undef $call_number if defined $call_number && $call_number !~ /\S/;
        push @$fields, marcfield(
            '852', ' ', ' ',
            'b' => $loc,
            _optional('h' => $call_number),
            _optional('x' => $classifier),
            '0' => $holding->id,
        );
        if ($add_items) {
            my @items = $holding->items;
            if (@items) {
                $num_items += @items;
                add_items_to_marc_fields(
                    'fields' => $fields,
                    'items' => \@items,
                    'call_number' => $call_number,
                );
            }
        }
    }
    return $num_items;
}

sub add_items_to_marc_fields {
    my %arg = @_;
    my ($fields, $items, $call_number) = @arg{qw(fields items call_number)};
    foreach my $item (@$items) {
        my $iloc = $item->location->code;
        my $vol = $item->volume;
        # my $year = $item->year_caption;
        # my $copies = @{ $item->copy_numbers || [] };
        my $item_call_number = join(' ', grep { defined && length } $call_number, $vol);
        undef $item_call_number if $item_call_number !~ /\S/;
        push @$fields, marcfield(
            '859', ' ', ' ',
            'b' => $iloc,
            defined($item_call_number) ? ('h' => $item_call_number) : (),
            '0' => $item->id,
        );
    }
}

sub _33x_field_subfields {
    my ($fields) = @_;
    my %f33x = map { $_ => {} } qw(336 337 338);
    foreach (@$fields) {
        my $tag = $_->[TAG];
        my $f = $f33x{$tag} or next;
        my $valref = $_->[VALREF];
        next if $$valref !~ /\x1f2rda/;
        if ($$valref =~ /\x1fb([^\x1d-\x1f]+)/) {
            $f33x{$tag}{$1} = 1;
        }
    }
    return \%f33x;
}

sub _marc_delete_stub {
    my ($id) = @_;
    my $leader = '00000dam a2200000 a 4500';
    my @fields = ( marcfield('001', $id) );
    return marcbuild($leader, \@fields);
}

sub print_cooked_marc {
    my %arg = @_;
    my $marcref = $arg{'marcref'} || \$arg{'marc'};
    my %sub = ('i' => $arg{'instance_id'}, 's' => $arg{'source_id'});
    my @s999;
    my %set;
    foreach (sort keys %sub) {
        $set{$_} = 1;
        push @s999, $_ => $sub{$_};
    }
    my $dirty;
    my ($leader, $fields);
    if (keys %set) {
        ($leader, $fields) = marcparse($marcref);
        $dirty = 1;
        my ($f999) = grep {
            $_->[TAG] eq '999' &&
            $_->[IND1] eq 'f'  &&
            $_->[IND2] eq 'f'
        } @$fields;
        if ($f999) {
            my $valref = $f999->[VALREF];
            while ($$valref =~ /\x1f([is])([^\x1d-\x1f]+)/g) {
                my $val = $sub{$_} or next;
                delete $set{$1} if $2 eq $val;
            }
            $f999->[DELETE] = $dirty = keys %set;
        }
    }
    elsif ($arg{'strict'}) {
        die "no instance or source record IDs to insert into MARC record"
    }
    if ($dirty) {
        push @$fields, marcfield('999', 'f', 'f', @s999);
        print marcbuild($leader, $fields);
    }
    else {
        print $$marcref;
    }
}

sub hook {
    my $what = shift;
    my $sub = __PACKAGE__->can('hook_'.$what)
        or return;
    $sub->(@_);
}

sub hook_login {
    1;
}

sub use_class {
    my ($cls) = @_;
    my $ok;
    eval qq{
        use $cls;
        \$ok = 1;
    };
    return if $ok;
    my ($err) = split /\n/, $@;
    fatal "use class $cls: $err";
}

sub orient {
    $root = '/usr/local/folio';
    usage if !defined $site_name;
    # $site_name = $1, shift @ARGV
    #     if $ARGV[0] =~ /^[@](.+)/;
    local $SIG{__WARN__} = sub {
        print @_ if $_[0] !~ /^Unknown option/;
    };
    GetOptions(
        @_,
        'r|root' => \$root,
        's|site=s' => \$site_name,
        'v|verbose' => \$verbose,
    ) or usage;
    $folio = Biblio::Folio->new('root' => $root);
    if (-l "$root/site/$site_name") {
        $site_name = readlink "$root/site/$site_name"
            or fatal "readlink $root/site/$site_name: $!";
        $site_name =~ s{.*/}{};
    }
    $site = $folio->site(
        $site_name,
        keys(%tracing) ? ('_tracing' => \%tracing) : (),
    );
    $json = JSON->new->pretty->canonical->convert_blessed;
    if ($cmd ne 'login') {
        login_if_necessary();
        # print STDERR "Reusing login for $site_name\n"
        #     if !login_if_necessary();
    }
}

sub _optional {
    my ($k, $v) = @_;
    return if !defined $v;
    return ($k, $v);
}

sub _parse_tracing {
    $tracing{'state'} = 'ON';
    foreach (split /:/, shift) {
        $tracing{'file'} = $1, next if m{^file=(.+)$};
        $tracing{'file'} = '/dev/stderr', next if $_ eq 'stderr';
        if (s/^show=//) {
            foreach (split /,/) {
                my $bool = s/^!// ? 0 : 1;
                $tracing{'show_'.$_} = $bool;
            }
        }
    }
}

sub fatal {
    print STDERR "$prog: @_\n";
    exit 2;
}

sub usage {
    my $usage;
    my @commands;
    my $cmd;
    foreach my $i (1..3) {
        my @caller = caller($i);
        last if !@caller;
        $cmd = $caller[3];
        last if $cmd =~ s/.+::cmd_//;
        undef $cmd;
    }
    if (@_) {
        $usage = '@SITE ' . shift;
    }
    if (defined $cmd && open my $fh, '<', $progfile) {
        my $incmd;
        while (<$fh>) {
            $incmd = $1, next if /^sub cmd_(\S+)/;
            undef($incmd), next if /^\}/;
            next if !/^(?:    |\t)usage "(.+)"/ || !$incmd;
            push @commands, $1;
            $usage = '@SITE ' . $1 if $incmd eq $cmd;
        }
    }
    $usage ||= '@SITE COMMAND [ARG...]';
    print STDERR "usage: $prog $usage\n";
    print STDERR "commands:\n" if @commands;
    print STDERR '  ', $_, "\n" for sort @commands;
    exit 1;
}

sub dd {
    my @lines;
    if (@_ >= 1 && eval { $_[0]->can('_uri') }) {
        my $obj = shift;
        my %obj = map {
            /^_/ ? ()
                 : ($_ => $obj->{$_})
        } keys %$obj;
        @lines = split /(?<=\n)/, Dump(bless \%obj, ref $obj);
    }
    else {
        @lines = split /(?<=\n)/, Dump(@_);
    }
    if (@lines > 50 && open my $fh, '|-', 'less') {
        print $fh @lines;
    }
    else {
        print @lines;
    }
}

# vim:set et ts=4 sw=4 cin si ai:
