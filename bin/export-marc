#!/usr/bin/perl

use strict;
use warnings;

use lib '/usr/local/folio/lib';

use Biblio::Folio;
use Biblio::Folio::Util qw(_utc_datetime);
use Biblio::LDP;

use Time::HiRes qw(time);
use JSON;
use Encode qw(decode encode);
use Getopt::Long
    qw(:config posix_default gnu_compat require_order bundling no_ignore_case);

# Phases
use constant BEGINNING => 'beginning';
use constant INSTANCES => 'instances';
use constant HOLDINGS  => 'holdings';
use constant ITEMS     => 'items';
use constant FINISHED  => 'finished';
use constant CANCELLED => 'cancelled';
use constant FAILED    => 'failed';

sub usage;
sub fatal;
sub unindent;

my $prog = $0;

my $root = '/usr/local/folio';
my %config = (
    'mode' => 'incremental',
    'small_batch_size' => 25,
    'large_batch_size' => 1000,
);

my ($all, $id_file, $skip_file, $time_file, $time_ref, $query, $postproc);
my ($spell_out_locations, $use_ldp, $use_srdb, $sync_srdb, $include_suppressed, $include_deleted, $out_file, $err_file, $comment, $verbose, $dryrun);
my $offset;
my $small_batch_size = 25;
my $large_batch_size = 1000;
GetOptions(
    # Modes (default is incremental)
    'a|all' => \$all,
    'q|query=s' => \$query,
    'f|id-file=s' => \$id_file,
    # Everything else
    'p|post-process-command=s' => \$postproc,
    'S|skip-file=s' => \$skip_file,
    'l|use-ldp' => \$use_ldp,
    'b|use-local-source-db' => \$use_srdb,
    'y|sync-local-source-db' => sub { $sync_srdb = $use_srdb = 1 },
    'x|include-suppressed' => \$include_suppressed,
    'd|include-deleted' => \$include_deleted,
    'o|output-file=s' => \$out_file,
    'e|errors-file=s' => \$err_file,
    't|time-file=s' => \$time_file,
    'r|time=s' => \$time_ref,
    'k|batch-size=i' => \$small_batch_size,
    'M|maximum-instance-count=i' => \$large_batch_size,
    'L|spell-out-locations' => \$spell_out_locations,
    'm|comment=s' => \$comment,
    'v|verbose' => \$verbose,
    'n|dry-run' => \$dryrun,
);
if (defined $out_file) {
    undef $out_file if $out_file eq '-' || $out_file eq '/dev/stdout';
}

usage if @ARGV != 1;
my $site_name = shift;
$site_name =~ s/^[@]//;

my $phase = BEGINNING;
my (%instance_id_to_holdings, %holdings_id_to_items);
my (%instances_seen, %holdings_seen, $cancelled, $failed);

$SIG{'TERM'} = $SIG{'INT'} = $SIG{'QUIT'} = sub { $cancelled = 1 };

my %skip;
if (defined $skip_file) {
    print STDERR "Reading skip file...";
    open my $fh, '<', $skip_file or fatal "open $skip_file: $!";
    while (<$fh>) {
        chomp;
        $skip{$_} = 1;
    }
    printf STDERR "done (%d records)\n", scalar(keys %skip);
}

# TODO
### fatal "harvesting without using the local source record DB is not yet implemented"
###     if !$use_srdb;
### fatal "harvesting without using LDP is not yet implemented"
###     if !$use_ldp;

my $folio = Biblio::Folio->new('root' => $root);
my $site = $folio->site($site_name);
my ($local_source_db, $exports_db, $ldp);

my $json = JSON->new;

my $t0 = my $tstart = time;
if ($sync_srdb) {
    print STDERR "Refreshing local source record DB\n";
    sync_local_source_db();
    printf STDERR "Refresh finished in %d second(s)\n", time - $tstart;
    $tstart = time;
}

$site->dont_cache(qw(instance source_record holdings_record item));

my ($out_fh, $err_fh);
my %counter = map { $_ => 0 } qw(batch seen instance error nonmarc suppressed deleted holdings skip);

if (defined $postproc) {
    # XXX Is this really necessary?
    $postproc = shell_quote(shellwords($postproc));
    $postproc .= " > $out_file" if defined $out_file;
    open $out_fh, "|$postproc"
        or fatal "exec $postproc: $!";
}
elsif (defined $out_file) {
    open $out_fh, '>', $out_file
        or fatal "open $out_file for writing: $!";
}
else {
    $out_fh = \*STDOUT;
}

if ($all) {
    usage if !$use_ldp;
    harvest_all();
}
elsif ($query) {
    harvest_by_query($query);
}
elsif ($id_file) {
    harvest_by_file($id_file);
}
elsif ($time_file) {
    die "not yet implemented";
    harvest_by_time_file($time_file);
}
elsif ($time_ref) {
    die "not yet implemented";
    harvest_by_time($time_ref);
}
else {
    harvest_incremental();
}
printf STDERR "Elapsed time: %s\n", sec2dur(time - $tstart);
print "Cancelled\n" if $cancelled;
print "Failed\n" if $failed;
if (!close $out_fh) {
    if (defined $postproc) {
        my $err = $!
            ? "error closing pipe ($!)"
            : "exit status $?";
        fatal "post-processing failed: $err: $postproc";
    }
    else {
        fatal defined($out_file)
            ? "close output file $out_file: $!"
            : "close standard output: $!";
    }
}
exit 2 if $cancelled;
exit 3 if $failed;

# --- Main functions

sub harvest_all {
    print STDERR "Performing query...";
    my $sql = q{SELECT id, source, data FROM inventory_instances ORDER BY id};
    $sql .= qq{ OFFSET $offset} if defined $offset;
    $sql .= qq{ LIMIT   $large_batch_size} if defined $large_batch_size;
    my $sth = ldp()->query($sql);
    printf STDERR "done in %.1f seconds\n", time - $tstart;
    print STDERR "Timer reset (ignore time required for query)\n";
    $tstart = time;
    run('all', sub {
        _harvest_from_ldp_using_executed_sth($sth);
    });
}

sub harvest_incremental {
    my $last_export = last_export();
    if ($use_ldp) {
        my $ldp = ldp();
        my $sql = ldp_incremental_sql();
        my $sth = $ldp->query($sql, $ldp->timestamp($last_export));
        run('incremental', sub {
            _harvest_from_ldp_using_executed_sth($sth);
        });
    }
    elsif ($use_srdb) {
        my $utc_last_export = _utc_datetime($last_export);
        my $cql = "metadata.updatedDate > $utc_last_export";
        my $instances_searcher = $site->searcher('instance')->query($cql)->limit($large_batch_size);
        my $holdings_searcher = $site->searcher('holdings_record')->query($cql)->limit($small_batch_size);
        #my $items_searcher = $site->searcher('item')->query($cql)->limit($small_batch_size);
        run('incremental', sub {
            print STDERR "Export new, updated, and deleted instances\n";
            $phase = INSTANCES;
            _harvest_using_instance_searcher($instances_searcher);
            print STDERR "\nExport new, updated, and deleted holdings records\n";
            $phase = HOLDINGS;
            _harvest_using_holdings_searcher($holdings_searcher);
            #print STDERR "\nExport new, updated, and deleted items\n";
            #$phase = ITEMS;
            #_harvest_using_item_searcher($items_searcher);
        });
    }
    else {
        die "not implemented";
        #my $harvester = $site->harvester('instances_with_holdings');
        #$harvester->harvest('since' => $last_export);
    }
}

sub harvest_by_query {
    my ($query) = @_;
    if ($use_srdb) {
        my $searcher = $site->searcher('instance')->query($query)->limit($large_batch_size);
        run('special', sub {
            _harvest_using_instance_searcher($searcher);
        });
    }
    else {
        die "not implemented";
    }
}

sub harvest_by_file {
    my ($f) = @_;
    my $searcher = $site->searcher('instance')->by('file' => $f)->limit($small_batch_size);
    run('special', sub {
        _harvest_using_instance_searcher($searcher);
    });
}

# --- Supporting functions

sub run {
    my ($type, $sub) = @_;
    my $exports_db;
    my $began = int($t0);
    if (!$dryrun) {
        $exports_db = exports_db();
        my $sth = $exports_db->sth(q{
            INSERT  INTO bib_exports
                    (type, began, status, comment, num_records)
            VALUES  (?, ?, 'running', ?, 0);
        });
        $sth->execute($type, $began, $comment);
    }
    my $ok;
    eval {
        $DB::single = 1;
        $sub->();
        $ok = 1;
        $phase = FINISHED;
    };
    $DB::single = 1;
    if (!$ok) {
        $phase = $cancelled ? CANCELLED : FAILED;
    }
    show_progress();
    my $ended = int(time);
    my $num_records = $counter{'instance'} - $counter{'nonmarc'};
    if (!$dryrun) {
        my $sth = $exports_db->sth(q{
            UPDATE  bib_exports
            SET     status = ?,
                    ended = ?,
                    num_records = ?
            WHERE   began = ?
        });
        $sth->execute($phase, $ended, $num_records, $began);
    }
}

sub _harvest_from_ldp_using_executed_sth {
    my ($sth) = @_;
    my $batch = batch();
    show_progress(INSTANCES);
    while (!$cancelled) {
        my ($iid, $source, $data) = $sth->fetchrow_array;
        if (defined $iid) {
            next if $instances_seen{$iid};
            $counter{'seen'}++;
            if (!defined $data) {
                # LDP doesn't have the instance data, for some reason
                $counter{'error'}++;
            }
            elsif ($skip{$iid}) {
                $counter{'skip'}++;
            }
            else {
                $counter{'instance'}++;
                add_to_batch($batch, 'instance_id' => $iid, 'source' => $source, 'dataref' => \$data);
            }
        }
        my $size = $batch->{'size'};
        if ($size == $small_batch_size || !defined $iid) {
            process_batch($batch) if $size > 0;
            last if !defined $iid;
            $batch = batch();
        }
    }
    continue {
        show_progress();
    }
}

sub _harvest_using_instance_searcher {
    my ($searcher) = @_;
    my $batch = batch();
    show_progress(INSTANCES);
    while (!$cancelled) {
        my $instance = $searcher->next;
        if ($instance) {
            my $iid = $instance->id;
            next if $instances_seen{$iid};
            my %record = ('instance' => $instance);
            $counter{'instance'}++;
            $counter{'seen'}++;
            add_to_batch($batch, 'instance_id' => $iid, 'source_record' => $instance->source_record, 'instance' => $instance);
        }
        my $size = $batch->{'size'};
        if ($size == $small_batch_size || !defined $instance) {
            process_batch($batch) if $size > 0;
            last if !defined $instance;
            $batch = batch();
        }
    }
    continue {
        show_progress();
    }
}

sub _harvest_using_holdings_searcher {
    my ($searcher) = @_;
    my $batch = batch();
    show_progress(HOLDINGS);
    my %need_instance;
    while (!$cancelled) {
        my $holdings_record = $searcher->next or last;
        my $hid = $holdings_record->id;
        my $iid = $holdings_record->{'instanceId'};
        next if $instances_seen{$iid};
        $holdings_seen{$hid} = 1;
        $need_instance{$iid} = 1;
    }
    continue {
        show_progress();
    }
    my $isearcher = $site->searcher('instance')
        ->by('set' => [keys %need_instance])
        ->limit($small_batch_size);
    _harvest_using_instance_searcher($isearcher);
}

sub _harvest_using_item_searcher {
    my ($searcher) = @_;
    my $batch = batch();
    show_progress(ITEMS);
    my %need_holdings;
    while (!$cancelled) {
        my $item = $searcher->next or last;
        my $hid = $item->{'holdingsRecordId'};
        next if $holdings_seen{$hid};
        $need_holdings{$hid} = 1;
    }
    continue {
        show_progress();
    }
    my $hsearcher = $site->searcher('holdings_record')
        ->by('set' => [keys %need_holdings])
        ->limit($small_batch_size);
    _harvest_using_holdings_searcher($hsearcher);
}

### sub old_harvest_by_file {
###     my ($f) = @_;
###     my $sql = q{
###         SELECT  id, source, data
###         FROM    inventory_instances
###         WHERE   id IN (%s)
###     };
###     open my $fh, '<', $f or fatal "open $f: $!";
###     my @ids;
###     my %n2sth;
###     while (!$cancelled) {
###         my ($id, $source, $data);
###         $id = <$fh>;
###         if (defined $id) {
###             $counter{'instance'}++;
###             $counter{'seen'}++;
###             push @ids, $id;
###             next if @ids < $small_batch_size;
###         }
###         my $n = @ids
###             or last;
###         my $batch = batch();
###         my $sth = $n2sth{$n} ||= ldp()->query(sprintf $sql, join(',', '?' x $n));
###         $sth->execute(@ids);
###         my $results = $sth->fetchall_hashref('id');
###         while (($id, $source, $data) = $sth->fetchrow_array) {
###             add_to_batch($batch, 'instance_id' => $id, 'source' => $source, 'dataref' => \$data);
###         }
###         process_batch($batch);
###     }
###     continue {
###         show_progress();
###     }
### }

sub local_source_db {
    return $local_source_db ||= $site->local_source_database;
    # XXX Not yet: return $local_source_db ||= $site->local_db('source-records');
}

sub exports_db {
    return $exports_db ||= $site->local_db('exports');
}

sub ldp {
    return $ldp ||= Biblio::LDP->new(
        'root' => $root . '/site/' . $site_name,
        'name' => $site_name,
    );
}

sub instance {
    my ($record) = @_;
    my ($iid, $source) = @$record{qw(id source)};
    if ($source !~ /^MARC/i) {
        $record->{'nonmarc'} = 1;
        $counter{'nonmarc'}++;
        return undef;
    }
    my $instance = $record->{'instance'};
    if (!defined $instance) {
        my $dataref = $record->{'dataref'};
        if (!$dataref) {
            return error($record, 'no data reference!?');
        }
        $instance = eval { $site->instance($json->decode($$dataref)) };
        if (!defined $instance) {
            my ($msg) = split /\n/, $@;
            return error($record, $msg);
        }
    }
    elsif ($instance->{'discoverySuppress'}) {
        $record->{'suppressed'} = 1;
        $counter{'suppressed'}++;
        undef $instance if !$include_suppressed;
    }
    elsif ($instance->{'deleted'}) {
        $record->{'deleted'} = 1;
        $counter{'deleted'}++;
        undef $instance if !$include_deleted;
    }
    return $record->{'instance'} = $instance;
}

sub batch {
    return {
        'number' => ++$counter{'batch'},
        'size' => 0,
        'records' => [],
        'record_number_base' => $counter{'instance'},
    };
}

sub next_batch {
    my ($batch) = @_;
    $batch->{'number'}++;
    $batch->{'size'} = 0;
    $batch->{'records'} = [];
    $batch->{'record_number_base'} = $counter{'instance'};
}

sub add_to_batch {
    my ($batch, %record) = @_;
    my $n = ++$batch->{'size'};
    my $source_record = $record{'source_record'};
    if ($source_record) {
        $record{'source'} ||= $source_record->{'recordType'};
        $record{'source_record_id'} ||= $source_record->{'id'};
        if (!defined $record{'marcref'}) {
            my $raw = $source_record->{'rawRecord'};
            if (defined $raw) {
                my $marc = $raw->{'content'};
                # my $marc = eval { encode('UTF-8', $raw->{'content'}) };
                $record{'marcref'} = \$marc;
            }
        };
    }
    push @{ $batch->{'records'} }, {
        %record,
        'number_in_batch' => $n,
        'number' => $batch->{'record_number_base'} + $n,
    };
}

sub show_progress {
    my ($new_phase, $force) = @_;
    $phase = $new_phase, $force = 1 if defined $new_phase;
    my $seen = $counter{'seen'};
    my $ending = ($phase eq FINISHED || $phase eq CANCELLED || $phase eq FAILED);
    if ($force || $ending || $seen % 100 == 0) {
        # $b-- if !$ending && $b;  # We're still in the middle of the batch
        my $tdiff = int(time - $tstart);
        my $dur = sec2dur($tdiff);
        my $rate = $tdiff ? $counter{'instance'} / $tdiff : 0;
        printf STDERR "\r   %-9.9s : %4d batch : %7d instance : %7d skipped : %7d holdings : %4d error : %4d suppressed : %4d deleted : %4d non-MARC : %s elapsed : %5.1f/sec",
            lc $phase, @counter{qw(batch instance skip holdings error suppressed deleted nonmarc)}, $dur, $rate;
        print STDERR "\n" if $ending;
    }
}

sub sec2dur {
    my $S = shift;
    my ($H, $M) = (0, 0);
    if ($S > 3600) {
        $H = int($S / 3600);
        $S -= $H * 3600;
    }
    if ($S > 60) {
        $M = int($S / 60);
        $S -= $M * 60;
    }
    return sprintf '%02d:%02d:%02d', $H, $M, $S;
}

sub process_batch {
    my ($batch) = @_;
    my ($batch_number, $size, $records) = @$batch{qw(number size records)};
    my %need_holdings;
    my %id2instance;
    foreach my $record (@$records) {
        my $iid = $record->{'instance_id'};
        next if $instances_seen{$iid}++;
        my $instance = instance($record) or next;
        my $marcref = marcref($record) or next;
        $id2instance{$iid} = $instance;
        $instance->{'_marcref'} = $marcref;
    }
    my @ids = keys %id2instance;
    if (@ids) {
        my $searcher = $site->searcher('holdings_record', 'instanceId' => \@ids)->limit(scalar @ids);  # , '@limit' => scalar(@ids));
        foreach my $holdings_record ($searcher->all) {
            my $iid = $holdings_record->instance_id;
            my $instance = $id2instance{$iid};
            push @{ $instance->{'_holdings'} ||= [] }, $holdings_record;
            $counter{'holdings'}++;
        }
    }
    my $n = 0;
    my $record;
    foreach $record (@$records) {
        $n++;
        my $instance = $record->{'instance'};
        if ($instance) {
            my $iid = $instance->id;
            my $marc = eval { $instance->export_marc('spell_out_locations' => 1, 'with_locations' => 1) };
            if (!defined $marc) {
                error($record, 'could not export MARC record');
                next;
            }
            if ($record->{'suppressed'} || $record->{'deleted'}) {
                my $leader = $marc->leader;
                substr($leader, 5, 1) = 'd';  # Deleted
                $marc->leader($leader);
                $marc->is_dirty(1);
            }
            my $marc21 = eval { $marc->as_marc21 };
            if (!defined $marc21) {
                error($record, 'could not build MARC record');
                next;
            }
            print $out_fh $marc21;
        }
        else {
            error($record, 'unknown reason for undefined instance');
        }
    }
    continue {
        report_error($record) if error($record);
    }
}

sub marcref {
    my ($record) = @_;
    return $record->{'marcref'}
        if defined $record->{'marcref'};
    my $iid = $record->{'instance_id'};
    my $marcref = eval { local_source_db()->marcref($iid) }
        or return error($record, 'no source record in local DB');
    return $marcref;
}

sub error {
    my $record = shift;
    return $record->{'error'} if !@_;
    my $msg = shift;
    $record->{'error'} = [$phase, $counter{'instance'}, $counter{'batch'}, $record->{'instance_id'}, $msg];
    $counter{'error'}++;
    return undef;
}

sub sync_local_source_db {
    my $num_synced = 0;
    printf STDERR "\r%8d source records synced", $num_synced;
    local_source_db()->sync('progress' => sub {
        ($num_synced) = @_;
        printf STDERR "\r%8d source records synced", $num_synced
            if $num_synced % 100 == 0;
    });
    printf STDERR "\r%8d source records synced\n", $num_synced;
}

sub unindent {
    my @lines = split /\n/, shift;
    while (@lines) {
        shift @lines, next if $lines[0] !~ /\S/;
        pop   @lines, next if $lines[-1] !~ /\S/;
        last;
    }
    my $n = min_indent(@lines);
    substr($_, 0, $n) = '' for @lines;
    return join('', map { $_ . "\n" } @lines);
}

sub min_indent {
    my $minn = 2<<16;
    foreach (@_) {
        m{^(\s+)} or return 0;
        my $n = length $1;
        $minn = $n if $n < $minn;
    }
    return $minn;
}

sub report_error {
    my ($record) = @_;
    my $err = $record->{'error'};
    if (defined $err_file) {
        if (!defined $err_fh) {
            if ($err_file eq '-' || $err_file eq '/dev/stderr') {
                $err_fh = \*STDERR;
            }
            else {
                open $err_fh, '>', $err_file or fatal "open $err_file for writing: $!";
            }
            print $err_fh join("\t", qw(phase record_number batch_number instance_id error)), "\n";
        }
        print $err_fh join("\t", @$err), "\n";
    }
}

sub last_export {
    my $sth = exports_db()->sth(q{
        SELECT  max(began)
        FROM    bib_exports
        WHERE   type IN ('full', 'incremental')
        AND     status = 'finished'
    });
    $sth->execute;
    my ($began) = $sth->fetchrow_array;
    return $began || 0;
}

sub ldp_incremental_sql {
    q{
        SELECT  id, source, data
        FROM    inventory_instances
        WHERE   id IN (
                SELECT  id            AS bid
                FROM    history.inventory_instances
                WHERE   updated >= $1
            UNION
                SELECT  h.instance_id AS bid
                FROM    inventory_holdings h
                            INNER JOIN history.inventory_holdings hh ON h.id = hh.id
                WHERE   hh.updated >= $1
        /*
            UNION
                SELECT  h.instance_id AS bid
                FROM    inventory_items i
                            INNER JOIN history.inventory_items hi ON i.id = hi.id
                            INNER JOIN inventory_holdings h ON i.holdings_record_id = h.id
                WHERE   hi.updated >= $1
        */
        )
    };
}

sub usage {
    print STDERR <<"EOS";
usage: $prog [OPTION...] [SITE...]\n";
export type (default is an incremental export):
  -a              perform a full export
  -q QUERY        export by query (single site only)
  -f FILE         export by query (single site only)
options:
  -p COMMAND      run output through post-processing command [1]
  -S SKIPFILE     exclude instances by ID (i.e., UUID)
  -l              use LDP to decide what to export
  -b              fetch source records from local DB
  -y              sync local source DB before exporting
  -x              include suppressed instances and holdings records [2]
  -d              include deleted instances and holdings records [3]
  -o              output file
  -e              errors file [4]
  -t FILE         export changes since last-modified time of FILE (mtime)
  -r DATETIME     export changes since DATETIME
  -k NUM          small batch size (when running CQL queries with lists of IDs)
  -M NUM          large batch size (when running other queries)
  -L              spell out location codes in exported 852 fields
  -m              comment to record in the local exports DB
  -v              be verbose
  -n              perform a dry run -- no changes will be made to the file
                  system or any local DBs
notes:
  [1] COMMAND may include arguments and/or special shell syntax (redirects,
      pipes, etc.).
  [2] Suppressed instances will be indicated by the code "d" in the record
      status in the leader (i.e., byte 5); suppressed holdings records will
      have an additional subfield \$z containing the code "suppressed" in their
      852 field.
  [3] Any deleted objects that are encountered (doubtful) will be indicated
      as for suppressed instances and holdings records, except that holdings
      records will have "deleted" in 852 \$z instead of "suppressed".
EOS
    exit 1;
}
