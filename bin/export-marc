#!/usr/bin/perl

use strict;
use warnings;

use lib '/usr/local/folio/lib';

use Biblio::Folio;
use Biblio::Folio::Object::Instance;
use Biblio::Folio::Site::MARC;
use Biblio::Folio::Util qw(_utc_datetime _bool _bool2int _parse_uuid_range);
use Biblio::LDP;

use Time::HiRes qw(time);
use JSON;
use Encode qw(decode encode);
use IO::Handle;
use File::Spec;
use Scalar::Util qw(weaken);
use Getopt::Long
    qw(:config posix_default gnu_compat require_order bundling no_ignore_case);

use constant SRS_DATETIME_FORMAT => '%Y-%m-%dT%H:%M:%S.%JZ';

# Modes
use constant FULL        => 'full';
use constant INCREMENTAL => 'incremental';
use constant DELETES     => 'deletes';
use constant SPECIAL     => 'special';

# Other types (for recording in exports.db)
use constant TEST        => 'test';

# Phases
use constant NONE      => 'none';
use constant BEGINNING => 'beginning';
use constant DELETED_HOLDINGS  => 'deleted holdings';
use constant DELETED_INSTANCES => 'deleted instances';
use constant INSTANCES => 'instances';
use constant SOURCE    => 'source records';
use constant HOLDINGS  => 'holdings';
use constant ITEMS     => 'items';

# Statuses (also treated as phases)
use constant RUNNING   => 'running';
use constant COMPLETED => 'completed';
use constant CANCELLED => 'cancelled';
use constant FAILED    => 'failed';

use constant DEBUGGING => scalar keys %DB::;

sub blather;
sub blatherf;
sub usage;
sub fatal;

my $prog = $0;

my $root = $ENV{'FOLIO_ROOT'} ||= '/usr/local/folio';
my %config = (
    'mode' => INCREMENTAL,
    'small_batch_size' => 25,
    'large_batch_size' => 1000,
);
my %config_handler;

my ($full, $query, $id_file, $deletes);
my ($skip_file, $postproc, $id_field);
my ($config_file, $spell_out_locations, $copy_links_to_bib, $sync_lidb, $out_file, $comment, $dryrun, $test);
my (@range, $offset, $limit);
my $verbose = 1;  # Show progress but nothing else
my $use_ldp = 0;
my $use_lidb = 1;
my $small_batch_size = 25;
my $large_batch_size = 1000;
my ($include_suppressed, $include_deleted) = (1, 1);
my ($include_suppressed_holdings, $include_bare_instances) = (0, 0);
my ($err_file, $after, $before, $max_num_batches, $trace);
my $t0 = my $tstart = time;
my %progress = (
    'start' => $t0,
    'last_report' => 0,
    'report_interval' => 1.0,
    'next_report' => 0,
    'phase' => BEGINNING,
    'previous_phase' => NONE,
);

GetOptions(
    # Modes (default is incremental)
    'f|full' => \$full,
    'q|query=s' => \$query,
    'i|id-file=s' => \$id_file,
    'd|deletes' => \$deletes,
    # Options shared by export-marc-for-sites
    't|test' => \$test,
    'v|verbose' => sub { $verbose++ },
    'silent|quiet' => sub { $verbose = 0 },
    'n|dry-run' => \$dryrun,
    's|skip-file=s' => \$skip_file,
    'r|range=s' => sub {
        # When doing a full export, export only instances whose UUID falls in
        # the given range.  See parse_uuid() below for details.
        @range = uuid_range($_[1]);
    },
    # Everything else
    'c|config-file=s' => sub { read_config_file($_[1]) },
    'p|post-process-command=s' => \$postproc,
    'l|use-ldp' => \$use_ldp,
    'b|use-local-instances-db' => \$use_lidb,
    'F|direct-from-folio' => sub { $sync_lidb = $use_lidb = 0 },
    'y|sync-local-instances-db' => sub { $sync_lidb = $use_lidb = 1 },
    'X|exclude-suppressed' => sub { $include_suppressed = 0 },
    'D|exclude-deleted' => sub { $include_deleted = 0 },
    'x|include-suppressed-holdings' => \$include_suppressed_holdings,
    'B|include-bare-instances' => \$include_bare_instances,
    'o|output-file=s' => \$out_file,
    'e|errors-file=s' => \$err_file,
    'k|batch-size=i' => \$small_batch_size,
    'M|large-batch-size=i' => \$large_batch_size,
    'offset=i' => \$offset,
    'limit=i' => \$limit,
    'L|spell-out-locations' => \$spell_out_locations,
    '8|copy-links-to-bib' => \$copy_links_to_bib,
    'm|comment=s' => \$comment,
    'I|id-field=s' => \$id_field,
    'h|hrids' => sub { $id_field = 'hrid' },
    'T|time=s' => \$t0,
    'after=s' => \$after,
    'before=s' => \$before,
    'N|maximum-batch-count=i' => \$max_num_batches,
    'trace' => sub { $trace = 1 },
) or usage;
usage if @range && (defined $offset || defined $limit);
usage if defined $id_field && !defined $id_file;

if (defined $out_file) {
    undef $out_file if $out_file eq '-' || $out_file eq '/dev/stdout';
}
if (!defined $err_file) {
    usage "Option -v requires option -e FILE when standard error is not a terminal"
        if $verbose && !-t STDERR;
}

usage if @ARGV != 1;
my $site_name = shift;
$site_name =~ s/^[@]//;

my %param;
param(
    %config,
    'site' => $site_name,
);

my (%instance_id_to_holdings, %holdings_id_to_items);
my (%instance_seen, %holdings_seen, $cancelled, $failed);

$SIG{'TERM'} = $SIG{'INT'} = $SIG{'QUIT'} = sub { $cancelled = 1 };

my %skip;
if (defined $skip_file) {
    blather "Reading skip file...";
    open my $fh, '<', $skip_file or fatal "open $skip_file: $!";
    while (<$fh>) {
        chomp;
        $skip{$_} = 1;
    }
    blatherf "done (%d records)\n", scalar(keys %skip);
}

my $folio = Biblio::Folio->new('root' => $root);
my $site = $folio->site($site_name);
my $weak_site = $site;
weaken($weak_site);

my ($local_instances_db, $exports_db, $ldp);

my $json = JSON->new;

if ($use_lidb && $sync_lidb) {
    blather "Refreshing local instances DB\n";
    sync_local_instances_db();
    blatherf "Refresh finished in %d second(s)\n", time - $tstart;
    $tstart = time;
}

$site->dont_cache(qw(instance source_record holdings_record item));

my %counter = map { $_ => 0 } qw(batch seen instance error no_source not_marc suppressed deleted holdings skip);
my $err_fh;

if (defined $postproc) {
    $postproc .= " > $out_file" if defined $out_file;
    open STDOUT, "|$postproc"
        or fatal "exec $postproc: $!";
}
elsif (defined $out_file) {
    open STDOUT, '>', $out_file
        or fatal "open $out_file for writing: $!";
}

# $DB::single = 1;  # Breakpoint if running in debugger
if ($full) {
    export_full();
}
elsif ($query) {
    export_by_query($query);
}
elsif ($id_file) {
    export_by_file($id_file);
}
elsif ($deletes) {
    $include_deleted = 1;  # Just in case
    export_deletes();
}
else {
    export_incremental();
}

blather "\n";
blatherf "Elapsed time: %s\n", sec2dur(time - $tstart);
blather "Cancelled\n" if $cancelled;
blather "Failed\n" if $failed;

STDOUT->flush;
if (!close STDOUT) {
    if (defined $postproc) {
        my $err = $!
            ? "error closing pipe ($!)"
            : "exit status $?";
        fatal "post-processing failed: $err: $postproc";
    }
    else {
        fatal defined($out_file)
            ? "close output file $out_file: $!"
            : "close standard output: $!";
    }
}
exit 2 if $cancelled;
exit 3 if $failed;

# --- Main functions

sub export_full {
    if ($use_lidb) {
        my $lidb = local_instances_db();
        my $sql = q{
            SELECT  DISTINCT id, hrid, source_type, source, suppressed, deleted
            FROM    instances
        };
        $limit ||= 9_000_000 if defined $offset;
        if (@range) {
            $sql .= "WHERE   id BETWEEN '$range[0]' AND '$range[1]'\n";
        }
        elsif (defined $limit) {
            $sql .= "ORDER BY id\n";
            $sql .= "LIMIT   $limit\n";
            $sql .= "OFFSET  $offset\n" if defined $offset;
            $sql =~ s/^\s+//msg;
        }
        my $sth = $lidb->sth($sql);
        $sth->execute;
        run(FULL, sub {
            _export_from_lidb_using_executed_sth(INSTANCES, $sth, 'Full export', with(@_, 'mode' => FULL, 'sql' => $sql));
        });
    }
    else {
        my $ssearcher = $site->searcher('source_record')->uri('/source-storage/source-records')->limit($large_batch_size);
        run(FULL, sub {
            _export_source_records(SOURCE, $ssearcher, 'Export all source records with associated holdings', with(@_, 'mode' => FULL));
        });
    }
}

sub _export_from_lidb_using_executed_sth {
    my ($phase, $sth, $msg, %ctx) = @_;
    my $batch = batch();
    show_progress($phase, $msg, %ctx);
    my $prev_iid = '(none)';
    while (!$cancelled) {
        my $ok;
        my ($iid, $hrid, $source_type, $marc, $suppressed, $deleted);
        eval {
            ($iid, $hrid, $source_type, $marc, $suppressed, $deleted) = $sth->fetchrow_array;
            $source_type = '' if !defined $source_type;
            $ok = 1;
        };
        if (defined $iid) {
            $counter{'seen'}++;
            if (!defined $marc) {
                # LIDB doesn't have the source record, for some reason
                $counter{'error'}++;
            }
            elsif ($skip{$iid}) {
                $counter{'skip'}++;
            }
            else {
                $counter{'instance'}++;
###             my $source_record = {
###                 'id' => undef,
###                 'rawRecord' => {
###                     'content' => $marc,
###                 },
###             };
                add_to_batch($batch,
                    'instance_id' => $iid,
                    'instance_hrid' => $hrid,
                    #'sourceref' => \$data,
                    'source_type' => $source_type,
                    'marcref' => $source_type eq 'MARC' ? \$marc : undef,
                    #'source_record' => $source_record,
                    'deleted' => $deleted,
                    'suppressed' => $suppressed,
                );
            }
        }
        elsif (!$ok) {
            # $DB::single = 1;
            my $err = $DBI::errstr;
            print STDERR "DBI error in LIDB fetch (after ID $prev_iid): $err\n" if defined $err;
        }
        my $size = $batch->{'size'};
        if ($size == $small_batch_size || !defined $iid) {
            process_batch($batch) if $size > 0;
            last if !defined $iid;
            $batch = batch();
        }
        $prev_iid = $iid;
    }
    continue {
        show_progress();
    }
}

sub export_deletes {
    # my $last_export_began = last_export_began(DELETES);
    my $need_instance = _identify_deleted_holdings_records('Identify deleted holdings');
    my $isearcher = $site->searcher('instance')
        ->by('set' => [keys %$need_instance])
        ->limit($small_batch_size);
    run(DELETES, sub {
        _export_deleted_instances(DELETED_INSTANCES, 'Export deleted instances', with(@_));
        _export_instances(INSTANCES, $isearcher, 'Export instances with deleted holdings', with(@_));
    });
}

sub export_incremental {
    my $last_export_began = defined($after) ? $after : last_export_began();
    my $now = defined($before) ? $before : $t0;
    # Prepare for additions and updates
    my $utc_last_export = _utc_datetime($last_export_began);
    my $utc_now = _utc_datetime($now);
    blather "Incremental export: changes from $utc_last_export to $now\n";
    my $cql = "metadata.updatedDate > $utc_last_export and metadata.updatedDate < $utc_now";
    my $instance_exporter;
    my $deleted_holdings_exporter = sub {
        my $need_instance = _identify_deleted_holdings_records('Identify deleted holdings', $last_export_began, $now);
        return $site->searcher('instance')
            ->by('set' => [keys %$need_instance])
            ->limit($small_batch_size);
    };
    my $hsearcher = $site->searcher('holdings_record')->query($cql)->limit($small_batch_size);
    #my $items_searcher = $site->searcher('item')->query($cql)->limit($small_batch_size);
    if ($use_lidb) {
        my $lidb = local_instances_db();
        my $sql = q{
            SELECT  DISTINCT id, hrid, source_type, source, suppressed, deleted
            FROM    instances
            WHERE   last_modified >= ?
            ORDER   BY last_modified
        };
        my $sth = $lidb->sth($sql);
        $sth->execute($last_export_began);
        run(INCREMENTAL, sub {
            _export_from_lidb_using_executed_sth(INSTANCES, $sth,               'Export new and updated instances from local DB', with(@_, 'where' => "instances.last_modified >= $last_export_began"));
            _export_deleted_instances(DELETED_INSTANCES,                        'Export deleted instances', with(@_));
            _export_instances(DELETED_HOLDINGS, $deleted_holdings_exporter->(), 'Export instances with deleted holdings', with(@_));
            _export_holdings(HOLDINGS, $hsearcher,                              'Export new and updated holdings records', with(@_, 'cql' => $cql));
            #_export_using_item_searcher(ITEMS, $items_searcher,                'Export new and updated items', with(@_, 'since' => $last_export_began));
        });
    }
    else {
        my $ssearcher = $site->searcher('source_record')->uri('/source-storage/source-records');
        $ssearcher->param('updatedAfter' => _utc_datetime($last_export_began, SRS_DATETIME_FORMAT));
        $ssearcher->param('updatedBefore' => _utc_datetime($now, SRS_DATETIME_FORMAT));
        $ssearcher->param('orderBy' => 'updatedDate,DESC')->limit($large_batch_size);
        run(INCREMENTAL, sub {
            _export_source_records(SOURCE, $ssearcher,                          'Export new and updated source records', with(@_, 'updatedAfter' => $last_export_began, 'updatedBefore' => $t0));
            _export_deleted_instances(DELETED_INSTANCES,                        'Export deleted instances', with(@_));
            _export_instances(DELETED_HOLDINGS, $deleted_holdings_exporter->(), 'Export instances with deleted holdings', with(@_));
            _export_holdings(HOLDINGS, $hsearcher,                              'Export new and updated holdings records', with(@_, 'cql' => $cql));
            #_export_using_item_searcher(ITEMS, $items_searcher,                'Export new and updated items', with(@_, 'since' => $last_export_began));
        });
    }
### }
### else {
###     die "not implemented";
###     #my $harvester = $site->harvester('instances_with_holdings');
###     #$harvester->harvest('since' => $last_export_began);
### }
}

sub export_by_query {
    my ($query) = @_;
    if ($use_lidb) {
        my $searcher = $site->searcher('instance')->query($query)->limit($large_batch_size);
        run(SPECIAL, sub {
            _export_instances(INSTANCES, $searcher, "Export instances by query: $query", with(@_, 'query' => $query));
        });
    }
    else {
        die "not implemented";
    }
}

sub export_by_file {
    my ($f) = @_;
    my $searcher = $site->searcher('instance')->by('file' => $f)->limit($small_batch_size);
    $searcher->id_field($id_field) if defined $id_field;
    run(SPECIAL, sub {
        _export_instances(INSTANCES, $searcher, "Export instances using file of IDs: $f", with(@_, 'id_file' => $f, defined($id_field) ? ('id_field' => $id_field) : ()));
    });
}

# --- Supporting functions

sub with {
    return;  # TODO
    die "with(HASH1, ..., HASHN, KEY1 => VAL1, ..., KEYN => VALN)" if @_ % 2;
    my $n = @_ >> 1;
    return map {
        my $i = $_ * 2;
        my $k = $_[$i];
        my $v = $_[$i+1];
        (".$k" => $v)
    } (0..$n);
}
    
sub param {
    $param{'#'} ||= 0;
    if (@_ == 1) {
        return $param{shift()}[-1];
    }
    while (@_ >= 2) {
        my ($k, $v) = splice @_, 0, 2;
        $param{$k} = {
            'number' => ++$param{'#'},
            'name' => $k,
            'value' => $v,
        };
    }
}

sub params {
    return sort { $a->{'number'} <=> $b->{'number'} } values %param;
}

sub log_beginning {
    my ($began, $mode, $comment) = @_;
    $exports_db = exports_db();
    my $sth = $exports_db->sth(q{
        INSERT  INTO exports
                (mode, began, status, comment, num_records)
        VALUES  (?, ?, ?, ?, 0);
    });
    my $dbh = $exports_db->dbh;
    $dbh->begin_work;
    $sth->execute($mode, $began, RUNNING, $comment);
    my $export_id = $dbh->sqlite_last_insert_rowid;
    $dbh->commit;
    return $export_id;
}

sub log_result {
    my ($export_id, $began, $mode, $comment, $status, $ended, $num_records) = @_;
    my $sth = $exports_db->sth(q{
        UPDATE  exports
        SET     status = ?,
                ended = ?,
                num_records = ?
        WHERE   id = ?
    });
    $sth->execute($status, $ended, $num_records, $export_id);
}

sub run {
    my ($mode, $sub) = splice @_, 0, 2;
    $mode = TEST if $test;
    my $began = $t0;
    my $export_id = $dryrun ? 0 : log_beginning($began, $mode, $comment);
    my %ctx = (
        'config' => \%config,
        'run' => {
            'export_id' => $export_id,
            'mode' => $mode,
            'began' => $began,
            @_,
        },
    );
    my $status;
    # $DB::single = 1;  # Breakpoint if running in debugger
    eval {
        $sub->(%ctx);
        $status = COMPLETED;
    };
    my $err;
    if (!defined $status) {
        ($err) = split /\n/, $@;
        if ($cancelled) {
            $status = CANCELLED;
        }
        else {
            $status = FAILED;
            $failed = 1;
        }
    }
    my $ended = time;
    my $num_records = $counter{'instance'} - $counter{'not_marc'};
    #my $num_batches = --$counter{'batch'};
    # $DB::single = 1;  # Breakpoint if running in debugger
    log_result($export_id, $began, $mode, $comment, $status, $ended, $num_records)
        if !$dryrun;
    show_progress($status, 'Totals', %ctx);
    if (defined $err) {
        print STDERR "Error: $err\n";
    }
}

sub _export_from_ldp_using_executed_sth {
    my ($phase, $sth, $msg, %ctx) = @_;
    my $batch = batch();
    show_progress($phase, $msg, %ctx);
    my $prev_iid = '(none)';
    while (!$cancelled) {
        my $ok;
        my ($iid, $source_type, $source);
        eval {
           ($iid, $source_type, $source) = $sth->fetchrow_array;
           $ok = 1;
        };
        if (defined $iid) {
            # next if $instance_seen{$iid};
            $counter{'seen'}++;
            if (!defined $source) {
                # LDP doesn't have the instance source, for some reason
                $counter{'error'}++;
            }
            elsif ($skip{$iid}) {
                $counter{'skip'}++;
            }
            else {
                $counter{'instance'}++;
                add_to_batch(
                    $batch,
                    'instance_id' => $iid,
                    'source_type' => $source_type,
                    'sourceref' => \$source,
                );
            }
        }
        elsif (!$ok) {
            # $DB::single = 1;
            my $err = $DBI::errstr;
            print STDERR "DBI error in LDP fetch (after ID $prev_iid): $err\n" if defined $err;
            eval { ldp()->ping } or fatal "LDP connection lost?";
        }
        my $size = $batch->{'size'};
        if ($size == $small_batch_size || !defined $iid) {
            process_batch($batch) if $size > 0;
            last if !defined $iid;
            $batch = batch();
        }
        $prev_iid = $iid;
    }
    continue {
        show_progress();
    }
}

sub _export_deleted_instances {
    my ($phase, $msg, %ctx) = @_;
    my $batch = batch();
    show_progress($phase, $msg, %ctx);
    my ($isth, $searcher);
    if ($use_ldp) {
        $isth = ldp()->query(ldp_deleted_instances_sql());  # XXX Don't include unless necessary: , $ldp->timestamp($last_export_began));
    }
    else {
        $searcher = $site->searcher('instance')->query('deleted==true')->limit($large_batch_size);
    }
    while (!$cancelled) {
        my @add;
        if ($isth) {
            my ($iid) = $isth->fetchrow_array;
            @add = ('instance_id' => $iid) if defined $iid;
        }
        else {
            my $instance = $searcher->next;
            @add = ('instance' => $instance) if defined $instance;
        }
        if (@add) {
            $counter{'seen'}++;
            $counter{'deleted'}++;
            add_to_batch(
                $batch,
                @add,
                'source_type' => 'MARC',
                'deleted' => 1,
            );
        }
        my $size = $batch->{'size'};
        if ($size == $small_batch_size || !@add) {
            process_batch($batch) if $size > 0;
            last if !@add;
            $batch = batch();
        }
    }
    continue {
        show_progress();
    }
}

sub _identify_deleted_holdings_records {
    my ($msg, $last_export_began, $now) = @_;
    my $batch = batch();
    show_progress(DELETED_HOLDINGS, $msg);
    my $sth = ldp()->query(ldp_deleted_holdings_records_sql_and_params($last_export_began, $now));
    my %need_instance;
    my @hids;
    while (!$cancelled) {
        my ($hid) = $sth->fetchrow_array;
        if (defined $hid) {
            $counter{'holdings'}++;
            $holdings_seen{$hid} = 1;
            push @hids, $hid;
        }
        if (@hids == $small_batch_size || @hids > 0 && !defined $hid) {
            my @iids = hids2iids(@hids);
            $need_instance{$_} = 1 for @iids;
        }
        last if !defined $hid;
    }
    continue {
        show_progress();
    }
    return \%need_instance;
}

sub hids2iids {
    my @hids = @_;
    my $placeholders = join(', ', map { '?' } @hids);
    my $lidb = local_instances_db();
    my $sql = qq{
        SELECT  instance_id
        FROM    holdings
        WHERE   holdings_record_id IN ($placeholders)
    };
    my $sth = $lidb->sth($sql);
    $sth->execute(@hids);
    my $rows = $sth->fetchall_arrayref;
    return map { @$_ } @$rows;
}

sub _export_instances {
    my ($phase, $searcher, $msg, %ctx) = @_;
    my $batch = batch();
    show_progress(INSTANCES, $msg, %ctx);
    while (!$cancelled) {
        my $instance = $searcher->next;
        if ($instance) {
            my $iid = $instance->id;
            next if $instance_seen{$iid};
            $counter{'instance'}++;
            $counter{'seen'}++;
            add_to_batch($batch,
                'instance_id' => $iid,
                'source_record' => $instance->source_record,
                'instance' => $instance,
            );
        }
        my $size = $batch->{'size'};
        if ($size == $small_batch_size || !defined $instance) {
            process_batch($batch) if $size > 0;
            last if !defined $instance;
            $batch = batch();
        }
    }
    continue {
        show_progress();
    }
}

sub _export_source_records {
    my ($phase, $searcher, $msg, %ctx) = @_;
    my $batch = batch();
    show_progress($phase, $msg, %ctx);
    while (!$cancelled) {
        my $source_record = $searcher->next;
        if ($source_record) {
            my $iid = $source_record->{'externalIdsHolder'}{'instanceId'};
            if (!defined $iid) {
                error({'instance_id' => 'unknown'});
            }
            elsif ($instance_seen{$iid}) {
                next;
            }
            else {
                $counter{'instance'}++;
                $counter{'seen'}++;
                my $deleted = $source_record->{'deleted'};
                my $suppressed = $source_record->{'additionalInfo'}{'suppressDiscovery'};
                add_to_batch(
                    $batch,
                    'instance_id' => $iid,
                    'source_record' => $source_record,
                    'deleted' => $deleted,
                    'suppressed' => $suppressed,
                );
            }
        }
        my $size = $batch->{'size'};
        if ($size == $small_batch_size || !defined $source_record) {
            process_batch($batch) if $size > 0;
            last if !defined $source_record;
            $batch = batch();
        }
    }
    continue {
        show_progress();
    }
}

sub _export_holdings {
    my ($phase, $searcher, $msg, %ctx) = @_;
    my $batch = batch();
    show_progress(HOLDINGS, $msg, %ctx);
    my %need_instance;
    while (!$cancelled) {
        my $holdings_record = $searcher->next or last;
        my $hid = $holdings_record->id;
        my $iid = $holdings_record->{'instanceId'};
        next if $instance_seen{$iid};
        $holdings_seen{$hid} = 1;
        $need_instance{$iid} = 1;
    }
    continue {
        show_progress();
    }
    my $isearcher = $site->searcher('instance')
        ->by('set' => [keys %need_instance])
        ->limit($small_batch_size);
    _export_instances(INSTANCES, $isearcher, 'Export holdings');
}

### sub _export_using_item_searcher {
###     my ($phase, $searcher, $msg, %ctx) = @_;
###     my $batch = batch();
###     show_progress(ITEMS, $msg, %ctx);
###     my %need_holdings;
###     while (!$cancelled) {
###         my $item = $searcher->next or last;
###         my $hid = $item->{'holdingsRecordId'};
###         next if $holdings_seen{$hid};
###         $need_holdings{$hid} = 1;
###     }
###     continue {
###         show_progress();
###     }
###     my $hsearcher = $site->searcher('holdings_record')
###         ->by('set' => [keys %need_holdings])
###         ->limit($small_batch_size);
###     _export_holdings(HOLDINGS, $hsearcher, 'Export holdings with modified items');
### }

sub local_instances_db {
    if (!defined $local_instances_db) {
        $local_instances_db = $site->local_instances_database;
        $local_instances_db->dbh->do('PRAGMA cache_size = -2000');
    }
    return $local_instances_db;
    # XXX Not yet: return $local_instances_db ||= $site->local_db('instances');
}

sub exports_db {
    return $exports_db ||= $site->local_db('exports');
}

sub ldp {
    return $ldp ||= Biblio::LDP->new(
        'root' => $root . '/site/' . $site_name,
        'name' => $site_name,
    );
}

sub make_instance {
    my ($record) = @_;
    my ($iid, $hrid, $source_type) = @$record{qw(instance_id instance_hrid source_type)};
    if (!defined $source_type) {
        $record->{'no_source'} = 1;
        $counter{'no_source'}++;
        return undef;
    }
    if ($source_type ne 'MARC') {
        $record->{'not_marc'} = 1;
        $counter{'not_marc'}++;
        return undef;
    }
    my $instance = $record->{'instance'} ||= stub_instance($iid, 'hrid' => $hrid);
### if (!defined $instance) {
###     my $sourceref = $record->{'sourceref'};
###     if (!$sourceref) {
###         return error($record, 'no source reference!?');
###     }
###     $instance = eval { $site->instance($json->decode($$sourceref)) };
###     if (!defined $instance) {
###         my ($msg) = split /\n/, $@;
###         return error($record, $msg);
###     }
### }
### elsif ($instance->{'discoverySuppress'}) {
    if ($instance->{'discoverySuppress'}) {
        $record->{'suppressed'} = 1;
        $counter{'suppressed'}++;
        undef $instance if !$include_suppressed;
    }
    elsif ($instance->{'deleted'}) {
        $record->{'deleted'} = 1;
        $counter{'deleted'}++;
        undef $instance if !$include_deleted;
    }
    return $record->{'instance'} = $instance;
}

sub batch {
    return {
        'number' => ++$counter{'batch'},
        'size' => 0,
        'records' => [],
        'record_number_base' => $counter{'instance'},
    };
}

sub next_batch {
    my ($batch) = @_;
    $batch->{'number'}++;
    $batch->{'size'} = 0;
    $batch->{'records'} = [];
    $batch->{'record_number_base'} = $counter{'instance'};
}

sub add_to_batch {
    my ($batch, %record) = @_;
    my $batch_records = $batch->{'records'};
    my $n = ++$batch->{'size'};
    my $source_record = $record{'source_record'};
    if ($source_record) {
        $record{'source_type'} ||= $source_record->{'recordType'};
        $record{'source_record_id'} ||= $source_record->{'id'} || $source_record->{'recordId'};
        $record{'marcjson'} ||= $source_record->{'parsedRecord'}{'content'};
        if (!defined $record{'marcref'}) {
            my $marc = $source_record->{'rawRecord'}{'content'};
            # my $marc = eval { encode('UTF-8', $source_record->{'rawRecord'}{'content'}) };
            $record{'marcref'} = \$marc if defined $marc;
        };
    }
    $record{'number_in_batch'} = $n;
    $record{'number'} = $batch->{'record_number_base'} + $n,
    push @$batch_records, \%record;
### {
###     %record,
###     'number_in_batch' => $n,
###     'number' => $batch->{'record_number_base'} + $n,
### };
    show_progress() if ($n % 10) == 1;
}

sub show_progress {
    return if !$verbose;
    my ($phase, $msg, %ctx) = @_;
    my $prev_phase = $progress{'previous_phase'};
    $phase ||= $prev_phase;
    $progress{'phase'} = $phase;
    my $ending = ($phase eq COMPLETED || $phase eq CANCELLED || $phase eq FAILED);
    my $seen = $counter{'seen'};
    my $tnow = time;
    if ($phase ne $prev_phase || $ending || $tnow >= $progress{'next_report'} || $seen % 100 == 0) {
        # $b-- if !$ending && $b;  # We're still in the middle of the batch
        my $tdiff = $tnow - $tstart;
        my $dur = sec2dur($tdiff);
        my $rate = $tdiff ? $counter{'instance'} / $tdiff : 0;
        if ($phase ne $prev_phase) {
            blather "\n" if $prev_phase ne NONE;
            blather $msg, "\n" if defined $msg;
        }
        my $batch_str = sprintf('%10s', "batch $counter{'batch'}");
        blatherf "\r   %-17s : %s : %7d seen | %7d instances : %7d skipped : %7d holdings : %4d errors : %4d suppressed : %4d deleted : %4d no source : %4d non-MARC : %s elapsed : %5.1f/sec",
            lc $phase, $batch_str, @counter{qw(seen instance skip holdings error suppressed deleted no_source not_marc)}, $dur, $rate;
        blather "\n" if $ending;
        $progress{'last_report'} = $tnow;
        $progress{'next_report'} = $tnow + $progress{'report_interval'};
    }
    $progress{'previous_phase'} = $phase;
}

sub sec2dur {
    my $S = shift;
    my ($H, $M) = (0, 0);
    if ($S > 3600) {
        $H = int($S / 3600);
        $S -= $H * 3600;
    }
    if ($S > 60) {
        $M = int($S / 60);
        $S -= $M * 60;
    }
    return sprintf '%02d:%02d:%02d', $H, $M, $S;
}

sub uuid_range {
    my ($r) = @_;
    my ($l, $u) = eval { _parse_uuid_range($r) };
    usage "invalid UUID range: $r" if !defined $l || $l gt $u;
    return ($l, $u);
}

sub stub_instance {
    my ($id, %arg) = @_;
    my $instance = Biblio::Folio::Object::Instance->new('id' => $id);
    %$instance = ( %$instance, %arg ) if %arg;
    $instance->site($weak_site);
    return $instance;
}

sub stub_marc {
    return Biblio::Folio::Site::MARC->stub(@_);
}

sub process_batch {
    my ($batch) = @_;
    my ($batch_number, $size, $records) = @$batch{qw(number size records)};
    my %need_holdings;
    my %id2instance;
    foreach my $record (@$records) {
        my ($iid, $hrid, $instance) = @$record{qw(instance_id hrid instance)};
        if (defined $instance) {
            $iid ||= $record->{'instance_id'} = $instance->{'id'};
            $hrid ||= $record->{'instance_hrid'} = $instance->{'hrid'};
        }
        else {
            $iid = $record->{'instance_id'};
            $hrid = $record->{'instance_hrid'};
        }
        next if $instance_seen{$iid}++;
        make_instance($record) or next;
        # make_instance($record, 'hrid' => $hrid) or next;
        make_marc($record);
        # make_marc($record, 'instance' => $instance, 'instance_id' => $iid, 'instance_hrid' => $hrid);
        if (!$record->{'deleted'} && !$record->{'suppressed'}) {
            $instance->{'_holdings'} ||= [];
            $id2instance{$iid} = $instance;
        }
    }
    my @ids = keys %id2instance;
    if (@ids) {
        # Add holdings
        if ($use_ldp) {
            my $placeholders = join(', ', map { '?' } @ids);
            my $sql = qq{
                SELECT  instance_id, data
                FROM    inventory_holdings
                WHERE   instance_id IN ($placeholders)
            };
            my $sth = ldp()->query($sql, @ids);
            while (my ($iid, $source) = $sth->fetchrow_array) {
                my $holdings_record = eval { $site->holdings_record($json->decode($source)) };
                next if $holdings_record->{'discoverySuppress'}
                     && !$include_suppressed_holdings;
                my $instance = $id2instance{$iid};
                push @{ $instance->{'_holdings'} ||= [] }, $holdings_record;
                $counter{'holdings'}++;
            }
        }
        else {
            my $searcher = $site->searcher('holdings_record', 'instanceId' => \@ids)->limit(scalar @ids);  # , '@limit' => scalar(@ids));
            foreach my $holdings_record ($searcher->all) {
                next if $holdings_record->{'discoverySuppress'}
                     && !$include_suppressed_holdings;
                my $iid = $holdings_record->instance_id;
                my $instance = $id2instance{$iid};
                push @{ $instance->{'_holdings'} ||= [] }, $holdings_record;
                $counter{'holdings'}++;
            }
        }
    }
    my $n = 0;
    my $record;
    foreach $record (@$records) {
        $n++;
        my $instance = $record->{'instance'};
        if ($instance) {
            my $iid = $instance->id;
            $record->{'deleted'} ||= $instance->{'deleted'};
            $record->{'suppressed'} ||= $instance->{'discoverySuppress'};
            my $holdings_records = $instance->{'_holdings'};
            my $add_holdings = !$record->{'deleted'} && !$record->{'suppressed'};
            my $marc = eval {
                $instance->export_marc(
                    'marc' => $record->{'marc'},
                    'with_locations' => 1,
                    'with_holdings' => $add_holdings,
                    'holdings' => $holdings_records,
                    'spell_out_locations' => $spell_out_locations,
                    'copy_electronic_access' => $copy_links_to_bib,
                )
            };
            if (!defined $marc) {
                error($record, $instance->errors);
                next;
            }
            if ($record->{'suppressed'} || $record->{'deleted'} || !$holdings_records && !$include_bare_instances) {
                my $leader = $marc->leader;
                substr($leader, 5, 1) = 'd';  # Deleted
                $marc->leader($leader);
                $marc->is_dirty(1);
            }
            my $marc21 = eval { $marc->as_marc21 };
            if (!defined $marc21) {
                error($record, 'could not build MARC record');
                next;
            }
            print($marc21) or fatal "print record $n: $!";
        }
        else {
            # Instance is deleted or suppressed, and the user doesn't want those
            # error($record, 'unknown reason for undefined instance');
        }
    }
    continue {
        report_error($record) if error($record);
    }
    $cancelled = 1 if defined $max_num_batches && $counter{'batch'} == $max_num_batches;
}

sub make_marc {
    my ($record) = @_;
    my ($marc, $marcjson, $marcref);
    $marcjson = marcjson($record)
        or $marcref = marcref($record)
        or return error($record, 'no way to build a MARC record');
    my ($instance, $iid, $hrid) = @$record{qw(instance instance_id instance_hrid)};
    # $instance ||= $record->{'instance'};
    $instance->{'_marcjson'} = $marcjson;
    $instance->{'_marcref'} = $marcref;
    if (defined $marcjson) {
        $marc = Biblio::Folio::Site::MARC->new('marcjson' => $marcjson)->parse;
    }
    elsif ($marcref) {
        $marc = Biblio::Folio::Site::MARC->new('marcref' => $marcref)->parse;
    }
    elsif (defined $hrid) {
        $marc = stub_marc('instance' => $instance, 'hrid' => $hrid);
        $record->{'deleted'} = 1;  # XXX Really??
    }
    else {
        # All we have is the instance ID
        # No instance hrid, and no MARC record whose 001 field we can get it from
        return error($record, "can't build a MARC record to delete an instance unless we have its hrid");
    }
    if (!$marc->is_valid) {
        return error($record, "can't parse MARC record", $marc->errors);
    }
    if (!$record->{'deleted'} && !$record->{'suppressed'}) {
        # Fix record status if it happens to be "d" (Deleted)
        my $leader = $marc->leader;
        if (substr($leader, 5, 1) =~ tr/d/c/) {
            $marc->leader($leader);
        }
    }
    if (!defined $hrid) {
        # XXX This code assumes that the 001 field should contain the
        #     instance's hrid, not its id!!!
        my $f001 = $marc->field('001')  # XXX I don't think this is possible, but...
            or return error($record, "can't build a MARC record to delete an instance unless its source record has an 001 field");
        $instance->{'hrid'} = $f001->value;
    }
    $record->{'marc'} = $marc;
}

sub marcjson {
    my ($record) = @_;
    return $record->{'marcjson'};
}

sub marcref {
    my ($record) = @_;
    return $record->{'marcref'}
        if defined $record->{'marcref'};
    my $iid = $record->{'instance_id'};
    my $marcref = eval { local_instances_db()->marcref($iid) }
        or return error($record, 'no MARC source record for instance in local DB');
    return $marcref;
}

sub error {
    my $record = shift;
    return $record->{'error'} if !@_;
    $record->{'error'} ||= [$progress{'phase'}, $record->{'number'} || $counter{'instance'}, $counter{'batch'}, $record->{'instance_id'}, @_];
    $counter{'error'}++;
    return undef;
}

sub sync_local_instances_db {
    my $num_synced = 0;
    printf STDERR "\r%8d records synced", $num_synced;
    my @errors;
    local_instances_db()->sync('progress' => sub {
        my $errors;
        ($num_synced, $errors) = @_;
        printf STDERR "\r%8d records synced, %d error(s)", $num_synced, scalar(@$errors)
            if $num_synced % 100 == 0;
        push @errors, @$errors if @$errors;
    });
    printf STDERR "\r%8d records synced\n", $num_synced;
    print STDERR "error: ", $_, "\n" for @errors;
}

sub report_error {
    my ($record) = @_;
    my $err = $record->{'error'};
    if (!defined $err_fh) {
        if (!defined $err_file || $err_file eq '-' || $err_file eq '/dev/stderr') {
            $err_fh = \*STDERR;
        }
        else {
            open $err_fh, '>', $err_file or fatal "open $err_file for writing: $!";
        }
        $err_fh->autoflush(1);
        print $err_fh join("\t", qw(phase record_number batch_number instance_id error)), "\n";
    }
    my @err = @$err;
    my @pfx = splice(@err, 0, 4);
    @err = ('unknown error') if !@err;
    foreach my $msg (@err) {
        print $err_fh join("\t", @pfx, $msg), "\n";
    }
}

sub last_export_began {
    my @modes = @_;
    @modes = (FULL, INCREMENTAL) if !@modes;
    my $placeholders = join(', ', map { '?' } @modes);
    my $sql = qq{
        SELECT  max(began)
        FROM    exports
        WHERE   status = ?
        AND     mode IN ($placeholders)
    };
    my $sth = exports_db()->sth($sql);
    $sth->execute(COMPLETED, @modes);
    my ($began) = $sth->fetchrow_array;
    return $began || 0;
}

sub read_config_file {
    my ($f) = @_;
    open my $fh, '<', $f or fatal "open $f: $!";
    while (<$fh>) {
        next if /^\s*(?:#.*)?$/;  # Skip blank lines and comments
        read_config_file(File::Spec->rel2abs($1, $f)), next
            if /^\@include\s+(.+)/;
        chomp;
        /^([^=]+)=\s*(.*)$/ or fatal "invalid line in config file $f: $_";
        my ($rawkey, $val) = ($1, $2);
        my $key = normkey($rawkey);
        set_config($key, $val);
    }
    close $fh or fatal "close $f: $!";
}

sub set_config {
    my ($key, $val) = @_;
    set_config_handlers() if !keys %config_handler;
    my $handler = $config_handler{$key} or fatal "unrecognized config setting: $key";
    $handler->($val, $key);
}

sub set_config_handlers {
    %config_handler = (
        'mode' => sub {
            my ($val) = @_;
            grep { $_ eq $val } (FULL, INCREMENTAL, DELETES, SPECIAL, TEST)
                or die "invalid mode in config settings: $val";
        },
        'use_hrids' => sub { $id_field = 'hrid' }, 
        'range' => sub { @range = uuid_range(shift) },
        'exclude_suppressed_instances' => sub { $include_suppressed = 0 },
        'exclude_deleted_instances' => sub { $include_deleted = 0 },
    );
    my %bool = (
        'full_export' => \$full,
        'deletes_only' => \$deletes,
        'test' => \$test,
        'verbose' => \$verbose,
        'dry_run' => \$dryrun,
        'use_ldp' => \$use_ldp,
        'use_local_instances_database' => \$use_lidb,
        'update_local_instances_database' => \$sync_lidb,
        'include-bare-instances' => \$include_bare_instances,
        'spell_out_locations' => \$spell_out_locations,
        'copy_links_to_bib_record' => \$copy_links_to_bib,
    );
    my %int = (
        'small_batch-size' => \$small_batch_size,
        'large_batch_size' => \$large_batch_size,
        'offset' => \$offset,
        'limit' => \$limit,
    );
    my %string = (
        'comment' => \$comment,
        'query' => \$query,
        'id_file' => \$id_file,
        'id_field' => \$id_field,
        'skip_file' => \$skip_file,
        'post_processing_command' => \$postproc,
        'output_file' => \$out_file,
        'errors_file' => \$err_file,
    );
    while (my ($k, $valref) = each %bool) {
        $config_handler{$k} = sub { $$valref = _bool2int(_bool(shift)) };
    }
    while (my ($k, $valref) = each %int) {
        $config_handler{$k} = sub {
            my ($val, $key) = @_;
            die "config setting $key must be an integer >= 0"
                if $val =~ /[^0-9]/;
            $$valref = $val;
        };
    }
    while (my ($k, $valref) = each %string) {
        $config_handler{$k} = sub { $$valref = shift };
    }
}

sub normkey {
    my $key = lc shift;
    $key =~ s/\s+/ /g;
    $key =~ s/^ | $//g;
    $key =~ tr/- /__/;
    return $key;
}

sub ldp_deleted_instances_sql {
    q{
        SELECT  hi.id
        FROM    history.inventory_instances hi
        LEFT OUTER JOIN
                public.inventory_instances pi
        ON      hi.id = pi.id
        WHERE   pi.id IS NULL
        /* XXX Don't include this unless it's truly needed
        AND     hi.updated >= ?
        */
    };
}

sub ldp_deleted_holdings_records_sql_and_params {
    my ($tb, $te) = @_;
    my $ldp = ldp();
    my $sql = q{
        SELECT  hh.id
        FROM    history.inventory_holdings hh
        LEFT OUTER JOIN
                public.inventory_holdings ph
        ON      hh.id = ph.id
        WHERE   ph.id IS NULL};
    my @params;
    if (defined $tb) {
        $sql .= ' AND hh.updated >= ?';
        push @params, $ldp->timestamp($tb);
        if (defined $te) {
            $sql .= ' AND hh.updated < ?';
            push @params, $ldp->timestamp($te);
        }
    }
    return $sql, @params;
}

sub junk {
    q{
        SELECT  id, source, data
        FROM    inventory_instances
        WHERE   id IN (
                SELECT  id            AS bid
                FROM    history.inventory_instances
                WHERE   updated >= $1
            UNION
                SELECT  h.instance_id AS bid
                FROM    inventory_holdings h
                            INNER JOIN history.inventory_holdings hh ON h.id = hh.id
                WHERE   hh.updated >= $1
        /*
            UNION
                SELECT  h.instance_id AS bid
                FROM    inventory_items i
                            INNER JOIN history.inventory_items hi ON i.id = hi.id
                            INNER JOIN inventory_holdings h ON i.holdings_record_id = h.id
                WHERE   hi.updated >= $1
        */
        )
    };
}

sub ldp_incremental_sql {
    q{
        SELECT  id, source, data
        FROM    inventory_instances
        WHERE   id IN (
                SELECT  id            AS bid
                FROM    history.inventory_instances
                WHERE   updated >= $1
            UNION
                SELECT  h.instance_id AS bid
                FROM    inventory_holdings h
                            INNER JOIN history.inventory_holdings hh ON h.id = hh.id
                WHERE   hh.updated >= $1
        /*
            UNION
                SELECT  h.instance_id AS bid
                FROM    inventory_items i
                            INNER JOIN history.inventory_items hi ON i.id = hi.id
                            INNER JOIN inventory_holdings h ON i.holdings_record_id = h.id
                WHERE   hi.updated >= $1
        */
        )
    };
}

sub blatherf {
    return if $verbose < 2;
    my $fmt = shift;
    printf STDERR $fmt, @_;
}

sub blather {
    print STDERR @_ if $verbose > 1;
}

sub usage {
    print STDERR "$prog: @_\n" if @_;
    print STDERR <<"EOS";
usage: $prog [OPTION...] [SITE...]
export mode (default is an incremental export):
  -f              perform a full export
  -q QUERY        export by query (single site only)
  -i FILE         export by file of instance IDs (single site only)
options:
  -p COMMAND      run output through post-processing command [1]
  -s SKIPFILE     exclude instances by ID (i.e., UUID)
  -l              use LDP to decide what to export
  -b              fetch instances from local DB
  -y              sync local instances DB before exporting
  -X              exclude suppressed instances and holdings records [2]
  -D              exclude deleted instances and holdings records [3]
  -o              output file
  -e              errors file [4]
  -t FILE         export changes since last-modified time of FILE (mtime)
  -r DATETIME     export changes since DATETIME
  -k NUM          small batch size (when running CQL queries with lists of IDs)
  -M NUM          large batch size (when running other queries)
  -L              spell out location codes in exported 852 fields
  -m              comment to record in the local exports DB
  -v              be verbose
  -n              perform a dry run -- no changes will be made to the file
                  system or any local DBs
notes:
  [1] COMMAND may include arguments and/or special shell syntax (redirects,
      pipes, etc.).
  [2] Unless this option is given, suppressed instances will be included, and
      will be indicated by the code "d" in the record status in the leader
      (i.e., byte 5); suppressed holdings records will have an additional
      subfield \$z containing the code "suppressed" in their 852 field.
  [3] Unless this option is given, any deleted objects that are encountered
      (doubtful) will be included, and will be indicated as for suppressed
      instances and holdings records, except that holdings records will have
      "deleted" in 852 \$z instead of "suppressed".
  [4] If this option is not given, errors will be silently discarded.
EOS
    exit 1;
}

sub fatal {
    print STDERR "$prog: @_\n";
    exit 2;
}

